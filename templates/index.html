<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ID By Rivoli</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @font-face {
            font-family: 'ClashGrotesk';
            src: url('/static/fonts/ClashGrotesk-Variable.ttf') format('truetype');
            font-weight: 200 700;
            font-display: swap;
        }
        
        :root {
            --bg-primary: #09090b;
            --bg-secondary: #18181b;
            --bg-tertiary: #27272a;
            --bg-card: rgba(24, 24, 27, 0.8);
            --border: #27272a;
            --border-hover: #3f3f46;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --accent: #fafafa;
            --accent-muted: rgba(250, 250, 250, 0.1);
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --radius: 12px;
            --radius-sm: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'ClashGrotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }

        /* Subtle grid pattern */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 64px 64px;
            pointer-events: none;
            z-index: 0;
        }

        .app {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px 24px;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 48px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-mark {
            width: 40px;
            height: 40px;
            background: var(--accent);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-mark svg {
            color: var(--bg-primary);
        }

        .logo-text {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .version {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 400; 
        }

        /* System Stats Bar */
        .stats-bar {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .stat-chip {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 100px;
            font-size: 13px;
            backdrop-filter: blur(8px);
        }

        .stat-chip svg {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
        }

        .stat-value {
            font-weight: 500;
            color: var(--text-primary);
        }

        .stat-label {
            color: var(--text-muted);
        }

        .stat-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 24px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            backdrop-filter: blur(8px);
            overflow: hidden;
        }

        .card-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title svg {
            width: 16px;
            height: 16px;
            color: var(--text-muted);
        }

        .card-body {
            padding: 24px;
        }

        /* Upload Zone */
        .upload-zone {
            border: 1px dashed var(--border);
            border-radius: var(--radius-sm);
            padding: 48px 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
        }

        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: var(--accent);
            background: var(--accent-muted);
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 16px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            color: var(--text-muted);
        }

        .upload-title {
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 6px;
        }

        .upload-subtitle {
            font-size: 13px;
            color: var(--text-muted);
        }

        .upload-actions {
            margin-top: 20px;
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 18px;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            border-radius: var(--radius-sm);
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn svg {
            width: 14px;
            height: 14px;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
        }

        .btn-ghost:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-full {
            width: 100%;
            padding: 14px 24px;
            font-size: 14px;
            margin-top: 20px;
        }

        /* File List */
        .file-list {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: var(--radius-sm);
            font-size: 13px;
            color: var(--text-secondary);
        }

        .file-item:hover {
            background: var(--bg-tertiary);
        }

        .file-item svg {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-count {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 12px;
        }

        .file-count-label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .file-count-value {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }

        /* Progress */
        .progress-section {
            display: none;
            margin-top: 24px;
        }

        .progress-section.active {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .progress-label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .progress-value {
            font-size: 13px;
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }

        .progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 100px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 100px;
        }

        .progress-status {
            margin-top: 12px;
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .progress-status svg {
            width: 12px;
            height: 12px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spin {
            animation: spin 1s linear infinite;
        }

        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* Queue Card */
        .queue-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .queue-count {
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-muted);
        }

        .queue-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .queue-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            font-size: 13px;
        }

        .queue-item-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .queue-item-status.processing {
            background: var(--warning);
            animation: pulse 1s infinite;
        }

        .queue-item-status.waiting {
            background: var(--text-muted);
        }

        .queue-item-status.done {
            background: var(--success);
        }

        .queue-item-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-secondary);
        }

        .queue-item-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 100px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }

        .queue-empty {
            padding: 32px;
            text-align: center;
            color: var(--text-muted);
            font-size: 13px;
        }

        /* Track Status Summary */
        .track-status-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 500;
        }

        .status-badge svg {
            width: 12px;
            height: 12px;
        }

        .status-badge.uploading {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
        }

        .status-badge.processing {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }

        .status-badge.waiting {
            background: rgba(161, 161, 170, 0.15);
            color: var(--text-muted);
        }

        .status-badge.completed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }

        .status-badge.skipped {
            background: rgba(161, 161, 170, 0.1);
            color: var(--text-muted);
        }

        .status-badge.failed {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }

        /* Full Track List */
        .full-track-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 500px;
            overflow-y: auto;
        }

        .track-list-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            font-size: 12px;
            transition: all 0.15s ease;
        }

        .track-list-item:hover {
            background: var(--bg-tertiary);
        }

        .track-checkbox {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.15s ease;
        }

        .track-checkbox svg {
            width: 12px;
            height: 12px;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .track-checkbox.checked {
            background: var(--success);
            border-color: var(--success);
        }

        .track-checkbox.checked svg {
            color: white;
            opacity: 1;
        }

        .track-checkbox.uploading {
            border-color: #3b82f6;
        }

        .track-checkbox.uploading svg {
            color: #3b82f6;
            opacity: 1;
            animation: spin 1s linear infinite;
        }

        .track-checkbox.processing {
            border-color: var(--warning);
        }

        .track-checkbox.processing svg {
            color: var(--warning);
            opacity: 1;
            animation: spin 1s linear infinite;
        }

        .track-checkbox.waiting {
            border-color: var(--text-muted);
        }

        .track-list-item-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-secondary);
        }

        .track-list-item-status {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 100px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            font-weight: 500;
            flex-shrink: 0;
        }

        .track-list-item-status.uploading {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
        }

        .track-list-item-status.processing {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }

        .track-list-item-status.waiting {
            background: rgba(161, 161, 170, 0.15);
            color: var(--text-muted);
        }

        .track-list-item-status.completed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }

        .track-list-item-status.uploaded {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
        }

        .track-list-item-status.failed {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }

        .track-list-item-status.skipped {
            background: rgba(161, 161, 170, 0.1);
            color: var(--text-muted);
        }

        .track-checkbox.failed {
            border-color: var(--error);
            background: rgba(239, 68, 68, 0.1);
        }

        .track-checkbox.failed svg {
            color: var(--error);
            opacity: 1;
        }

        .track-checkbox.skipped {
            border-color: var(--text-muted);
            background: rgba(161, 161, 170, 0.1);
        }

        .track-checkbox.skipped svg {
            color: var(--text-muted);
            opacity: 1;
        }

        .track-list-item-progress {
            width: 60px;
            height: 3px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .track-list-item-progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s ease;
        }

        .track-list-section-header {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 12px 12px 6px 12px;
            margin-top: 8px;
        }

        .track-list-section-header:first-child {
            margin-top: 0;
        }

        /* Workers Card */
        .workers-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .worker-cell {
            aspect-ratio: 1;
            border-radius: var(--radius-sm);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-muted);
            transition: all 0.2s ease;
        }

        .worker-cell.active {
            background: var(--accent-muted);
            border-color: var(--accent);
            color: var(--accent);
        }

        .worker-cell.busy {
            background: rgba(245, 158, 11, 0.1);
            border-color: var(--warning);
            color: var(--warning);
        }

        /* Stats Card */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-box {
            padding: 16px;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
        }

        .stat-box-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .stat-box-header svg {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
        }

        .stat-box-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-box-value {
            font-size: 24px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .stat-box-sub {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Results Section */
        .results-section {
            display: none;
            margin-top: 32px;
        }

        .results-section.active {
            display: block;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-title {
            font-size: 16px;
            font-weight: 600;
        }

        .results-count {
            font-size: 13px;
            color: var(--text-muted);
        }

        .track-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            margin-bottom: 12px;
            overflow: hidden;
        }

        .track-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .track-icon {
            width: 36px;
            height: 36px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .track-icon svg {
            width: 18px;
            height: 18px;
            color: var(--text-muted);
        }

        .track-info {
            flex: 1;
        }

        .track-name {
            font-size: 14px;
            font-weight: 500;
        }

        .track-meta {
            font-size: 12px;
            color: var(--text-muted);
        }

        .track-edits {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        .edit-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 20px;
            border-bottom: 1px solid var(--border);
        }

        .edit-item:last-child {
            border-bottom: none;
        }

        .edit-name {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .edit-actions {
            display: flex;
            gap: 6px;
        }

        .dl-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 500;
            font-family: inherit;
            border-radius: 6px;
            text-decoration: none;
            transition: all 0.15s ease;
        }

        .dl-btn-mp3 {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .dl-btn-mp3:hover {
            opacity: 0.9;
        }

        .dl-btn-wav {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .dl-btn-wav:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-hover);
        }

        /* Log Panel */
        .log-panel {
            display: none;
            margin-top: 16px;
        }

        .log-panel.active {
            display: block;
        }

        .log-content {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 12px;
            max-height: 160px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-entry {
            color: var(--text-muted);
            padding: 2px 0;
        }

        .log-entry.success {
            color: var(--success);
        }

        .log-entry.error {
            color: var(--error);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 100px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 14px 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        /* History Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .modal-overlay.show .modal {
            transform: scale(1);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .history-table th,
        .history-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .history-table th {
            font-weight: 500;
            color: var(--text-muted);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .history-table td {
            color: var(--text-secondary);
        }

        .history-table tr:hover td {
            background: var(--bg-tertiary);
        }

        .history-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 500;
        }

        .history-status.completed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }

        .history-status.failed {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }

        .history-status.uploaded,
        .history-status.processing {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }

        .history-stats {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
        }

        .history-stat {
            padding: 12px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            text-align: center;
        }

        .history-stat-value {
            font-size: 20px;
            font-weight: 600;
        }

        .history-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .history-type {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }

        .history-type.instrumental {
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
        }

        .history-type.acapella {
            background: rgba(236, 72, 153, 0.15);
            color: #f472b6;
        }

        .history-type.extended {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .history-empty {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast svg {
            width: 16px;
            height: 16px;
        }

        .toast.success svg {
            color: var(--success);
        }

        /* Hidden inputs */
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <div class="logo-mark">
                    <i data-lucide="audio-waveform" width="20" height="20"></i>
                </div>
                <div>
                    <div class="logo-text">ID By Rivoli</div>
                    <div class="version">{{ version_info }}</div>
                </div>
            </div>
            <div class="stats-bar" id="statsBar">
                <button class="btn btn-secondary" onclick="openHistoryModal()" style="padding: 8px 14px;">
                    <i data-lucide="history"></i>
                    History
                </button>
                <div class="stat-chip">
                    <i data-lucide="cpu"></i>
                    <span class="stat-value" id="cpuValue">--</span>
                    <span class="stat-label">CPU</span>
                </div>
                <div class="stat-chip">
                    <i data-lucide="hard-drive"></i>
                    <span class="stat-value" id="ramValue">--</span>
                    <span class="stat-label">RAM</span>
                </div>
                <div class="stat-chip" id="gpuChip" style="display: none;">
                    <div class="stat-dot"></div>
                    <span class="stat-value" id="gpuValue">H100</span>
                    <span class="stat-label" id="gpuMem">80GB</span>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-grid">
            <!-- Left Column: Upload & Results -->
            <div class="main-content">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <i data-lucide="upload-cloud"></i>
                            Upload Audio Files
                        </div>
                        <button class="btn btn-ghost" onclick="clearFiles()" id="clearBtn" style="display: none;">
                            <i data-lucide="trash-2"></i>
                            Clear
                        </button>
                    </div>
                    <div class="card-body">
                        <form id="uploadForm">
                            <div class="upload-zone" id="dropZone">
                                <div class="upload-icon">
                                    <i data-lucide="music"></i>
                                </div>
                                <div class="upload-title">Drop MP3 files or folders here</div>
                                <div class="upload-subtitle">or click to browse</div>
                                <div class="upload-actions">
                                    <button type="button" class="btn btn-secondary" onclick="document.getElementById('fileInput').click()">
                                        <i data-lucide="file-audio"></i>
                                        Select Files
                                    </button>
                                    <button type="button" class="btn btn-secondary" onclick="document.getElementById('folderInput').click()">
                                        <i data-lucide="folder"></i>
                                        Select Folder
                                    </button>
                                </div>
                                <input type="file" id="fileInput" accept=".mp3" multiple>
                                <input type="file" id="folderInput" webkitdirectory directory multiple>
        </div>

                            <div id="fileListSection" style="display: none;">
                                <div class="file-count">
                                    <span class="file-count-label">Selected files</span>
                                    <span class="file-count-value" id="fileCount">0 files</span>
                                </div>
                                <div class="file-list" id="fileList"></div>
            </div>
            
                            <div class="progress-section" id="progressSection">
                                <div class="progress-header">
                                    <span class="progress-label" id="progressLabel">Uploading...</span>
                                    <span class="progress-value" id="progressValue">0%</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progressFill"></div>
                                </div>
                                <div class="progress-status" id="progressStatus">
                                    <i data-lucide="loader-2"></i>
                                    <span id="statusText">Initializing...</span>
                                </div>
            </div>
            
                            <div class="log-panel" id="logPanel">
                                <div class="log-content" id="logContent"></div>
                            </div>

                            <button type="submit" class="btn btn-primary btn-full" id="submitBtn">
                                <i data-lucide="play"></i>
                                Start Processing
                            </button>
        </form>
                    </div>
                </div>

                <!-- Results -->
                <div class="results-section" id="resultsSection">
                    <div class="results-header">
                        <div>
                            <div class="results-title">Processed Tracks</div>
                            <div class="results-count" id="resultsCount">0 tracks ready</div>
            </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-ghost" onclick="clearResults()">
                                <i data-lucide="trash-2"></i>
                                Clear
                            </button>
                            <a href="/download_all_zip" class="btn btn-primary">
                                <i data-lucide="archive"></i>
                                Download All
                            </a>
                        </div>
                    </div>
                    <div id="resultsList"></div>
                </div>
            </div>

            <!-- Right Column: Sidebar -->
            <div class="sidebar">
                <!-- Workers -->
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <i data-lucide="boxes"></i>
                            Workers
                        </div>
                        <span class="queue-count" id="workersActive">0 / 16</span>
                    </div>
                    <div class="card-body">
                        <div class="workers-grid" id="workersGrid"></div>
        </div>
    </div>

                <!-- Full Track List -->
                <div class="card">
                    <div class="card-header">
                        <div class="queue-header">
                            <div class="card-title">
                                <i data-lucide="list-checks"></i>
                                All Tracks
                            </div>
                            <span class="queue-count" id="totalTrackCount">0</span>
                        </div>
                    </div>
                    <div class="card-body" style="padding: 12px;">
                        <!-- Status summary -->
                        <div class="track-status-summary" id="trackStatusSummary">
                            <div class="status-badge uploading" id="uploadingBadge" style="display: none;">
                                <i data-lucide="upload"></i>
                                <span id="uploadingCount">0</span> uploading
                            </div>
                            <div class="status-badge processing" id="processingBadge" style="display: none;">
                                <i data-lucide="loader-2" class="spin"></i>
                                <span id="processingCount">0</span> processing
                            </div>
                            <div class="status-badge waiting" id="waitingBadge" style="display: none;">
                                <i data-lucide="clock"></i>
                                <span id="waitingCount">0</span> waiting
                            </div>
                            <div class="status-badge completed" id="completedBadge" style="display: none;">
                                <i data-lucide="check-circle-2"></i>
                                <span id="completedCount">0</span> done
                            </div>
                            <div class="status-badge failed" id="failedBadge" style="display: none; background: rgba(239, 68, 68, 0.2); color: var(--error);">
                                <i data-lucide="alert-circle"></i>
                                <span id="failedCount">0</span> failed
                                <button onclick="retryFailedFiles()" style="margin-left: 8px; padding: 2px 8px; background: var(--error); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Retry</button>
                            </div>
                            <div class="status-badge skipped" id="skippedBadge" style="display: none;">
                                <i data-lucide="skip-forward"></i>
                                <span id="skippedCount">0</span> skipped
                            </div>
                        </div>
                        
                        <!-- Full track list -->
                        <div class="full-track-list" id="fullTrackList">
                            <div class="queue-empty">No tracks yet</div>
                        </div>
                    </div>
                </div>

                <!-- System Stats -->
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <i data-lucide="gauge"></i>
                            System
                </div>
            </div>
                    <div class="card-body">
                        <div class="stats-grid">
                            <div class="stat-box">
                                <div class="stat-box-header">
                                    <i data-lucide="zap"></i>
                                    <span class="stat-box-label">GPU</span>
                                </div>
                                <div class="stat-box-value" id="gpuUsage">--%</div>
                                <div class="stat-box-sub" id="gpuName">Detecting...</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-box-header">
                                    <i data-lucide="database"></i>
                                    <span class="stat-box-label">Memory</span>
                                </div>
                                <div class="stat-box-value" id="memUsage">--%</div>
                                <div class="stat-box-sub" id="memAvail">-- GB available</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-box-header">
                                    <i data-lucide="hard-drive"></i>
                                    <span class="stat-box-label">Disk</span>
                                </div>
                                <div class="stat-box-value" id="diskUsage">--%</div>
                                <div class="stat-box-sub" id="diskFree">-- GB free</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-box-header">
                                    <i data-lucide="activity"></i>
                                    <span class="stat-box-label">Throughput</span>
                                </div>
                                <div class="stat-box-value" id="throughput">--</div>
                                <div class="stat-box-sub">tracks/min</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <i data-lucide="check-circle"></i>
        <span id="toastMessage">Success</span>
    </div>

    <!-- History Modal -->
    <div class="modal-overlay" id="historyModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">
                    <i data-lucide="history"></i>
                    Upload History
                </div>
                <button class="btn btn-ghost" onclick="closeHistoryModal()">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="history-stats" id="historyStats">
                    <div class="history-stat">
                        <div class="history-stat-value" id="historyTotal">0</div>
                        <div class="history-stat-label">Total</div>
                    </div>
                    <div class="history-stat">
                        <div class="history-stat-value" style="color: var(--success);" id="historyCompleted">0</div>
                        <div class="history-stat-label">Completed</div>
                    </div>
                    <div class="history-stat">
                        <div class="history-stat-value" style="color: var(--error);" id="historyFailed">0</div>
                        <div class="history-stat-label">Failed</div>
                    </div>
                    <div class="history-stat">
                        <div class="history-stat-value" style="color: var(--warning);" id="historyPending">0</div>
                        <div class="history-stat-label">Pending</div>
                    </div>
                </div>
                <div id="historyTableContainer">
                    <table class="history-table">
                        <thead>
                            <tr>
                                <th>Filename</th>
                                <th>Status</th>
                                <th>Type</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody id="historyTableBody">
                            <tr><td colspan="4" class="history-empty">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="modal-footer">
                <div style="display: flex; gap: 8px;">
                    <a href="/history/csv" class="btn btn-secondary" download>
                        <i data-lucide="download"></i>
                        Download CSV
                    </a>
                    <button class="btn btn-ghost" onclick="clearHistory()">
                        <i data-lucide="trash-2"></i>
                        Clear History
                    </button>
                </div>
                <button class="btn btn-primary" onclick="closeHistoryModal()">
                    Close
                </button>
            </div>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();
    
        let selectedFiles = [];
        let pollingInterval = null;
        let statsInterval = null;
        let numWorkers = 16;
        let processedCount = 0;
        let startTime = null;
        let isUploading = false;
        let lastResultsCount = 0;
        
        // Full track tracking system
        // Status: 'selected' | 'uploading' | 'waiting' | 'processing' | 'completed'
        let allTracks = {}; // { filename: { status: string, progress: number, worker: number|null } }

        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const folderInput = document.getElementById('folderInput');
        const fileList = document.getElementById('fileList');
        const fileListSection = document.getElementById('fileListSection');
        const fileCount = document.getElementById('fileCount');
        const clearBtn = document.getElementById('clearBtn');
        const submitBtn = document.getElementById('submitBtn');
        const progressSection = document.getElementById('progressSection');
        const progressFill = document.getElementById('progressFill');
        const progressValue = document.getElementById('progressValue');
        const progressLabel = document.getElementById('progressLabel');
        const statusText = document.getElementById('statusText');
        const logPanel = document.getElementById('logPanel');
        const logContent = document.getElementById('logContent');
        const resultsSection = document.getElementById('resultsSection');
        const resultsList = document.getElementById('resultsList');
        const resultsCount = document.getElementById('resultsCount');
        const workersGrid = document.getElementById('workersGrid');

        // File handling
        fileInput.addEventListener('change', (e) => handleNewFiles(Array.from(e.target.files)));
        folderInput.addEventListener('change', (e) => handleNewFiles(Array.from(e.target.files)));

        function handleNewFiles(files) {
            const mp3s = files.filter(f => f.name.toLowerCase().endsWith('.mp3'));
            const newFiles = [];
            mp3s.forEach(file => {
                if (!selectedFiles.some(f => f.name === file.name && f.size === file.size)) {
                    selectedFiles.push(file);
                    newFiles.push(file);
                }
            });
            // Add to full track list as 'selected'
            if (newFiles.length > 0) {
                addTracksToList(newFiles, 'selected');
            }
            updateFileList();
        }

        function clearFiles() {
            // Remove only selected/not-yet-uploaded files from track list
            selectedFiles.forEach(file => {
                if (allTracks[file.name]?.status === 'selected') {
                    delete allTracks[file.name];
                }
            });
            selectedFiles = [];
            updateFileList();
            updateFullTrackListUI();
            fileInput.value = '';
            folderInput.value = '';
        }

        function updateFileList() {
            fileCount.textContent = `${selectedFiles.length} files`;
            fileListSection.style.display = selectedFiles.length > 0 ? 'block' : 'none';
            clearBtn.style.display = selectedFiles.length > 0 ? 'flex' : 'none';
            
            fileList.innerHTML = '';
            const limit = 20;
            selectedFiles.slice(0, limit).forEach(file => {
                    const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <i data-lucide="file-audio"></i>
                    <span class="file-name">${file.name}</span>
                `;
                fileList.appendChild(item);
            });
            
                if (selectedFiles.length > limit) {
                    const more = document.createElement('div');
                more.className = 'file-item';
                more.innerHTML = `<i data-lucide="more-horizontal"></i><span class="file-name">and ${selectedFiles.length - limit} more...</span>`;
                fileList.appendChild(more);
            }
            
            lucide.createIcons();
        }

        // Drag & Drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(event => {
            dropZone.addEventListener(event, (e) => {
            e.preventDefault();
            e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(event => {
            dropZone.addEventListener(event, () => dropZone.classList.add('dragover'));
        });

        ['dragleave', 'drop'].forEach(event => {
            dropZone.addEventListener(event, () => dropZone.classList.remove('dragover'));
        });

        dropZone.addEventListener('drop', async (e) => {
            const items = e.dataTransfer.items;
            let files = [];

            if (items) {
                const queue = [];
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry?.();
                        if (entry) queue.push(entry);
                        else {
                            const file = item.getAsFile();
                            if (file) files.push(file);
                        }
                    }
                }
                
                while (queue.length > 0) {
                    const entry = queue.shift();
                    if (entry.isFile) {
                        files.push(await new Promise(r => entry.file(r)));
                    } else if (entry.isDirectory) {
                        const entries = await new Promise(r => {
                            const reader = entry.createReader();
                            const results = [];
                            const readEntries = () => {
                                reader.readEntries(e => {
                                    if (!e.length) r(results);
                                    else { results.push(...e); readEntries(); }
                                });
                            };
                            readEntries();
                        });
                        queue.push(...entries);
                    }
                }
            } else {
                files = Array.from(e.dataTransfer.files);
            }
            
            handleNewFiles(files);
        });

        // Upload file with progress tracking using XMLHttpRequest
        // With auto_enqueue=true, files are immediately queued for analysis after upload
        // This enables parallel upload + processing for better storage efficiency
        function uploadFileWithProgress(file, fileIndex, totalFiles, autoEnqueue = true) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const formData = new FormData();
                formData.append('file', file);
                
                // Auto-enqueue: immediately add to processing queue after upload
                // This allows analysis to start while more files are still uploading
                if (autoEnqueue) {
                    formData.append('auto_enqueue', 'true');
                }
                
                // Track upload progress
                xhr.upload.addEventListener('progress', (event) => {
                    if (event.lengthComputable) {
                        const filePercent = Math.round((event.loaded / event.total) * 100);
                        
                        // Calculate overall progress: completed files + current file progress
                        const completedFilesPercent = (fileIndex / totalFiles) * 100;
                        const currentFileContribution = (filePercent / totalFiles);
                        const overallPercent = Math.round(completedFilesPercent + currentFileContribution);
                        
                        // Update main progress bar
                        progressFill.style.width = overallPercent + '%';
                        progressValue.textContent = overallPercent + '%';
                        
                        // Update status text with file-specific progress
                        const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
                        const uploadedMB = (event.loaded / (1024 * 1024)).toFixed(1);
                        // Show just the filename (not the path for folder uploads)
                        const displayName = file.name.split('/').pop().split('\\').pop();
                        statusText.textContent = `Uploading ${fileIndex + 1}/${totalFiles}: ${displayName} (${uploadedMB}/${fileSizeMB} MB - ${filePercent}%)`;
                        
                        // Update track list item progress
                        updateTrackStatus(file.name, 'uploading', filePercent);
                    }
                });
                
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            // Parse JSON response to get server's sanitized filename
                            const response = JSON.parse(xhr.responseText);
                            resolve(response);
                        } catch (e) {
                            // If not JSON, just resolve with the raw response
                            resolve({ filename: file.name });
                        }
                    } else {
                        try {
                            const errorResponse = JSON.parse(xhr.responseText);
                            reject(new Error(errorResponse.error || `Upload failed: ${xhr.status}`));
                        } catch (e) {
                            reject(new Error(`Upload failed: ${xhr.status}`));
                        }
                    }
                });
                
                xhr.addEventListener('error', () => {
                    reject(new Error('Network error during upload'));
                });
                
                xhr.addEventListener('abort', () => {
                    reject(new Error('Upload aborted'));
                });
                
                xhr.open('POST', '/upload_chunk');
                xhr.send(formData);
            });
        }

        // Configurable batch upload settings for 1000+ file handling
        const UPLOAD_BATCH_SIZE = 10;  // Number of concurrent uploads
        const ENQUEUE_BATCH_SIZE = 20; // Number of concurrent enqueue calls
        
        // Batch upload helper - uploads multiple files concurrently
        // With autoEnqueue=true (default), files are immediately queued for processing
        async function uploadBatch(files, startIdx, totalFiles, autoEnqueue = true) {
            const results = await Promise.allSettled(
                files.map((file, batchIdx) => {
                    const globalIdx = startIdx + batchIdx;
                    updateTrackStatus(file.name, 'uploading', 0);
                    return uploadFileWithProgress(file, globalIdx, totalFiles, autoEnqueue)
                        .then(result => ({ file, result, success: true }))
                        .catch(error => ({ file, error, success: false }));
                })
            );
            return results.map(r => r.status === 'fulfilled' ? r.value : { ...r.reason, success: false });
        }
        
        // Batch enqueue helper - enqueues multiple files concurrently
        async function enqueueBatch(filenames) {
            const results = await Promise.allSettled(
                filenames.map(filename => 
                    fetch('/enqueue_file', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filename })
                    }).then(r => r.ok ? r.json() : Promise.reject(new Error(`Enqueue failed: ${r.status}`)))
                )
            );
            return results;
        }

        // Form submit - optimized for 1000+ track batch uploads
        // With auto-enqueue: files are uploaded AND queued for analysis in one step
        // This enables parallel upload + processing for better storage efficiency
        document.getElementById('uploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            if (selectedFiles.length === 0) {
                showToast('Please select at least one file');
                return;
            }

            if (isUploading) {
                showToast('Upload in progress, please wait...');
                return;
            }

            isUploading = true;
            progressSection.classList.add('active');
            logPanel.classList.add('active');
            resultsSection.classList.add('active');
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<i data-lucide="loader-2" class="spin"></i> Uploading & Processing...';
            lucide.createIcons();
            
            if (!startTime) startTime = Date.now();

            statusText.textContent = 'Uploading & queueing files...';
            progressLabel.textContent = 'Upload + Queue';

            // Start polling if not already running
            if (!pollingInterval) startPolling();
            if (!statsInterval) startStatsPolling();

            const filesToUpload = [...selectedFiles];
            const totalFiles = filesToUpload.length;
            
            // Clear selection immediately so user can add more
            selectedFiles = [];
            updateFileList();
            
            // Show batch info for large uploads
            if (totalFiles >= 100) {
                addLog(` Starting batch upload of ${totalFiles} files with auto-queue (${UPLOAD_BATCH_SIZE} concurrent)...`, 'info');
            }

            let uploadedCount = 0;
            let failedCount = 0;
            let skippedCount = 0;
            let queuedCount = 0;
            
            // Process uploads in batches for better throughput
            // With auto_enqueue=true, each file is immediately queued for analysis after upload
            for (let i = 0; i < totalFiles; i += UPLOAD_BATCH_SIZE) {
                const batch = filesToUpload.slice(i, i + UPLOAD_BATCH_SIZE);
                const batchNum = Math.floor(i / UPLOAD_BATCH_SIZE) + 1;
                const totalBatches = Math.ceil(totalFiles / UPLOAD_BATCH_SIZE);
                
                if (totalFiles >= 50) {
                    statusText.textContent = `Uploading batch ${batchNum}/${totalBatches} (${uploadedCount}/${totalFiles} done, ${queuedCount} queued)...`;
                }
                
                // Upload batch concurrently (with auto_enqueue=true)
                const batchResults = await uploadBatch(batch, i, totalFiles);
                
                // Process results
                for (const result of batchResults) {
                    if (result.success) {
                        const serverFilename = result.result.filename || result.file.name;
                        const response = result.result;
                        uploadedCount++;
                        
                        // Update track name if it was sanitized by server
                        if (serverFilename !== result.file.name) {
                            delete allTracks[result.file.name];
                        }
                        
                        // Handle different auto-enqueue results
                        if (response.skipped) {
                            // Track was already processed - skip
                            skippedCount++;
                            allTracks[serverFilename] = { status: 'skipped', progress: 100, worker: null };
                            addLog(` Skipped (already processed): ${serverFilename}`, 'info');
                        } else if (response.auto_enqueued) {
                            // File was uploaded AND queued for processing
                            queuedCount++;
                            allTracks[serverFilename] = { status: 'waiting', progress: 100, worker: null };
                        } else if (response.auto_enqueue_blocked) {
                            // Auto-enqueue was blocked due to too many pending downloads
                            allTracks[serverFilename] = { status: 'uploaded', progress: 100, worker: null };
                            addLog(` Queue blocked: ${serverFilename} - too many pending tracks`, 'warning');
                        } else {
                            // File was uploaded but not auto-enqueued (fallback)
                            allTracks[serverFilename] = { status: 'uploaded', progress: 100, worker: null };
                        }
                    } else {
                        failedCount++;
                        addLog(`Failed: ${result.file?.name || 'Unknown'} - ${result.error?.message || 'Unknown error'}`, 'error');
                        removeTrackFromList(result.file?.name);
                    }
                }
                
                // Update overall progress (full 100% since upload+queue is one step now)
                const uploadProgress = Math.round((i + batch.length) / totalFiles * 100);
                progressFill.style.width = uploadProgress + '%';
                progressValue.textContent = uploadProgress + '%';
                updateFullTrackListUI();
            }
            
            // No separate enqueue phase needed - files are already queued during upload!
            
            updateFullTrackListUI();

            progressFill.style.width = '100%';
            progressValue.textContent = '100%';
            progressLabel.textContent = 'Processing';
            
            // Build status message
            let statusMsg = `${queuedCount} files queued for processing`;
            if (skippedCount > 0) {
                statusMsg += ` (${skippedCount} skipped - already processed)`;
            }
            statusText.textContent = statusMsg;
            
            if (failedCount > 0) {
                addLog(` ${failedCount} files failed to upload`, 'error');
            }
            if (skippedCount > 0) {
                addLog(` ${skippedCount} files skipped (already processed)`, 'info');
            }
            
            // Re-enable upload immediately - users can add more files while processing
            isUploading = false;
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i data-lucide="plus"></i> Add More Files';
            lucide.createIcons();
            
            let toastMsg = `${queuedCount} files queued`;
            if (skippedCount > 0) toastMsg += `, ${skippedCount} skipped`;
            if (failedCount > 0) toastMsg += `, ${failedCount} failed`;
            showToast(toastMsg);
        });

        function startPolling() {
            if (pollingInterval) return; // Already polling
            
            pollingInterval = setInterval(async () => {
                try {
                    const res = await fetch('/status');
                    const status = await res.json();

                    numWorkers = status.num_workers || 16;
                    updateWorkersUI(status.active_workers || 0, numWorkers);

                    // Update logs
                    if (status.logs?.length > 0) {
                        logContent.innerHTML = status.logs.slice(-50).map(log => 
                            `<div class="log-entry">${escapeHtml(log)}</div>`
                        ).join('');
                        logContent.scrollTop = logContent.scrollHeight;
                    }

                    // Get list of completed track names from results
                    const completedTracks = (status.results || []).map(r => r.original);
                    
                    // Get failed files from server status
                    const failedFiles = status.failed_files || [];
                    
                    // Sync full track list with server queue items (including failed files)
                    syncTracksFromQueueItems(status.queue_items || [], completedTracks, failedFiles);

                    // Always update results if there are new ones
                    if (status.results?.length > 0 && status.results.length !== lastResultsCount) {
                        displayResults(status.results);
                        lastResultsCount = status.results.length;
                    }

                    // Update status text based on state
                    if (status.state === 'processing') {
                        progressLabel.textContent = 'Processing';
                        let statusMsg = status.current_step || 'Processing...';
                        if (status.current_filename) {
                            statusMsg += ` - ${status.current_filename}`;
                        }
                        if (status.queue_size > 0) {
                            statusMsg += ` (${status.queue_size} in queue)`;
                        }
                        statusText.textContent = statusMsg;
                    } else if (status.state === 'idle') {
                        if (status.queue_size > 0) {
                            statusText.textContent = `${status.queue_size} tracks waiting...`;
                        } else {
                            progressLabel.textContent = 'Ready';
                            statusText.textContent = 'Ready for new files';
                        }
                    } else if (status.state === 'error') {
                        statusText.textContent = 'Error: ' + status.error;
                    }
                } catch (e) {
                    console.error('Polling error:', e);
                }
            }, 1000);
        }

        function startStatsPolling() {
            const updateStats = async () => {
                try {
                    const res = await fetch('/system_stats');
                    const stats = await res.json();

                    document.getElementById('cpuValue').textContent = stats.cpu.percent + '%';
                    document.getElementById('ramValue').textContent = stats.memory.used_percent + '%';

                    if (stats.gpu.available) {
                        document.getElementById('gpuChip').style.display = 'flex';
                        document.getElementById('gpuValue').textContent = stats.gpu.name.split(' ').pop();
                        document.getElementById('gpuMem').textContent = stats.gpu.memory_gb + 'GB';
                        document.getElementById('gpuUsage').textContent = stats.gpu.memory_used_percent + '%';
                        document.getElementById('gpuName').textContent = stats.gpu.name;
                    }

                    document.getElementById('memUsage').textContent = stats.memory.used_percent + '%';
                    document.getElementById('memAvail').textContent = stats.memory.available_gb + ' GB available';
                    document.getElementById('diskUsage').textContent = stats.disk.used_percent + '%';
                    document.getElementById('diskFree').textContent = stats.disk.free_gb + ' GB free';

                    // Estimate throughput
                    if (startTime && processedCount > 0) {
                        const elapsed = (Date.now() - startTime) / 60000;
                        const rate = Math.round(processedCount / elapsed);
                        document.getElementById('throughput').textContent = rate || '--';
                    }
                } catch (e) {}
            };
            
            updateStats();
            statsInterval = setInterval(updateStats, 2000);
        }

        function updateWorkersUI(active, total) {
            document.getElementById('workersActive').textContent = `${active} / ${total}`;
            workersGrid.innerHTML = '';
            
            for (let i = 0; i < total; i++) {
                const cell = document.createElement('div');
                cell.className = 'worker-cell' + (i < active ? ' busy' : '');
                cell.textContent = i + 1;
                workersGrid.appendChild(cell);
            }
        }

        function updateQueueUI(queueItems) {
            const queueList = document.getElementById('queueList');
            const items = queueItems || [];
            
            document.getElementById('queueCount').textContent = items.length;
            
            if (items.length === 0) {
                queueList.innerHTML = '<div class="queue-empty">No tracks in queue</div>';
                return;
            }
            
            let html = '';
            const maxDisplay = 10;
            
            items.slice(0, maxDisplay).forEach((item, index) => {
                const isProcessing = item.status === 'processing';
                const statusClass = isProcessing ? 'processing' : 'waiting';
                const progress = item.progress || 0;
                const step = item.step || (isProcessing ? 'Processing...' : 'Waiting...');
                const workerInfo = item.worker ? `W${item.worker}` : '';
                
                html += `
                    <div class="queue-item" style="flex-direction: column; align-items: stretch; gap: 8px;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div class="queue-item-status ${statusClass}"></div>
                            <span class="queue-item-name" style="flex: 1;">${escapeHtml(item.filename)}</span>
                            ${workerInfo ? `<span class="queue-item-badge">${workerInfo}</span>` : ''}
                        </div>
                        ${isProcessing ? `
                            <div style="display: flex; align-items: center; gap: 8px; padding-left: 20px;">
                                <div style="flex: 1; height: 3px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden;">
                                    <div style="width: ${progress}%; height: 100%; background: var(--accent); transition: width 0.3s;"></div>
                                </div>
                                <span style="font-size: 11px; color: var(--text-muted); min-width: 35px;">${progress}%</span>
                            </div>
                            <div style="font-size: 11px; color: var(--text-muted); padding-left: 20px;">${escapeHtml(step)}</div>
                        ` : `
                            <div style="font-size: 11px; color: var(--text-muted); padding-left: 20px;">#${index + 1} in queue</div>
                        `}
                    </div>
                `;
            });
            
            if (items.length > maxDisplay) {
                html += `<div class="queue-item"><span class="queue-item-name" style="text-align:center;width:100%;color:var(--text-muted)">+${items.length - maxDisplay} more in queue</span></div>`;
            }
            
            queueList.innerHTML = html;
        }

        // Download with retry logic
        async function downloadWithRetry(url, filename, maxRetries = 3) {
            let lastError = null;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    showToast(`Downloading ${filename}...`);
                    
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            throw new Error('File not found (404) - may have expired');
                        }
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const blob = await response.blob();
                    const downloadUrl = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(downloadUrl);
                    document.body.removeChild(a);
                    
                    showToast(`Downloaded: ${filename}`);
                    return true;
                    
                } catch (error) {
                    lastError = error;
                    console.error(`Download attempt ${attempt}/${maxRetries} failed:`, error);
                    
                    if (attempt < maxRetries) {
                        showToast(`Retry ${attempt}/${maxRetries} for ${filename}...`);
                        // Wait before retry (exponential backoff: 1s, 2s, 4s)
                        await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt - 1)));
                    }
                }
            }
            
            // All retries failed
            showToast(`Download failed: ${filename} - ${lastError?.message || 'Unknown error'}`);
            console.error(`All ${maxRetries} download attempts failed for ${filename}:`, lastError);
            return false;
        }

        function handleDownload(event, url, filename) {
            event.preventDefault();
            downloadWithRetry(url, filename);
        }

        function displayResults(results) {
            processedCount = results.length;
            resultsCount.textContent = `${results.length} tracks ready`;
            resultsList.innerHTML = '';
            
            results.forEach(track => {
                const card = document.createElement('div');
                card.className = 'track-card';
                
                let editsHtml = track.edits.map(edit => {
                    const mp3Filename = edit.name + '.mp3';
                    const wavFilename = edit.name + '.wav';
                    return `
                        <div class="edit-item">
                            <span class="edit-name">${escapeHtml(edit.name)}</span>
                            <div class="edit-actions">
                                <a href="${edit.mp3}" class="dl-btn dl-btn-mp3" onclick="handleDownload(event, '${edit.mp3}', '${escapeHtml(mp3Filename)}')">MP3</a>
                                <a href="${edit.wav}" class="dl-btn dl-btn-wav" onclick="handleDownload(event, '${edit.wav}', '${escapeHtml(wavFilename)}')">WAV</a>
                            </div>
                        </div>
                    `;
                }).join('');

                card.innerHTML = `
                    <div class="track-header">
                        <div class="track-icon"><i data-lucide="disc-3"></i></div>
                        <div class="track-info">
                            <div class="track-name">${escapeHtml(track.original)}</div>
                            <div class="track-meta">${track.edits.length} versions</div>
                        </div>
                    </div>
                    <div class="track-edits">${editsHtml}</div>
                `;
                
                resultsList.appendChild(card);
            });

            lucide.createIcons();
            resultsSection.classList.add('active');
        }

        function resetForNewUpload() {
            isUploading = false;
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i data-lucide="play"></i> Start Processing';
            lucide.createIcons();
            selectedFiles = [];
            updateFileList();
            fileInput.value = '';
            folderInput.value = '';
        }

        function addLog(message, type = '') {
            const entry = document.createElement('div');
            entry.className = 'log-entry' + (type ? ' ' + type : '');
            entry.textContent = message;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            document.getElementById('toastMessage').textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        async function clearResults() {
            try {
                await fetch('/clear_results', { method: 'POST' });
                resultsList.innerHTML = '';
                resultsCount.textContent = '0 tracks ready';
                lastResultsCount = 0;
                processedCount = 0;
                startTime = null;
                logContent.innerHTML = '';
                
                // Clear the full track list
                allTracks = {};
                updateFullTrackListUI();
                
                showToast('Results cleared');
            } catch (e) {
                console.error('Clear error:', e);
            }
        }

        // Retry failed files - re-queue them for processing
        async function retryFailedFiles(specificFiles = null) {
            try {
                const body = specificFiles ? { filenames: specificFiles } : {};
                const response = await fetch('/retry_failed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const result = await response.json();
                
                if (result.retried > 0) {
                    // Update local track status to 'waiting' for retried files
                    (result.filenames || []).forEach(filename => {
                        if (allTracks[filename]) {
                            allTracks[filename].status = 'waiting';
                            allTracks[filename].progress = 0;
                            allTracks[filename].error = null;
                        }
                    });
                    updateFullTrackListUI();
                    showToast(` ${result.retried} fichier(s) remis en file d'attente`);
                } else {
                    showToast('Aucun fichier en chec  ressayer');
                }
            } catch (e) {
                console.error('Retry failed:', e);
                showToast('Erreur lors de la tentative de ressai');
            }
        }

        // Clear failed files from the list without retrying
        async function clearFailedFiles(specificFiles = null) {
            try {
                const body = specificFiles ? { filenames: specificFiles } : {};
                const response = await fetch('/clear_failed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const result = await response.json();
                
                if (result.cleared > 0) {
                    // Remove failed files from local track list
                    Object.keys(allTracks).forEach(filename => {
                        if (allTracks[filename].status === 'failed') {
                            if (!specificFiles || specificFiles.includes(filename)) {
                                delete allTracks[filename];
                            }
                        }
                    });
                    updateFullTrackListUI();
                    showToast(` ${result.cleared} fichier(s) effac(s)`);
                } else {
                    showToast('Aucun fichier en chec  effacer');
                }
            } catch (e) {
                console.error('Clear failed:', e);
                showToast('Erreur lors de la suppression');
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Track list management functions
        function addTracksToList(files, status = 'selected') {
            files.forEach(file => {
                const name = typeof file === 'string' ? file : file.name;
                if (!allTracks[name]) {
                    allTracks[name] = { status, progress: 0, worker: null };
                }
            });
            updateFullTrackListUI();
        }

        function updateTrackStatus(filename, status, progress = null, worker = null) {
            if (allTracks[filename]) {
                allTracks[filename].status = status;
                if (progress !== null) allTracks[filename].progress = progress;
                if (worker !== null) allTracks[filename].worker = worker;
            }
            updateFullTrackListUI();
        }

        function removeTrackFromList(filename) {
            delete allTracks[filename];
            updateFullTrackListUI();
        }

        function updateFullTrackListUI() {
            const container = document.getElementById('fullTrackList');
            const entries = Object.entries(allTracks);
            
            // Update total count
            document.getElementById('totalTrackCount').textContent = entries.length;
            
            // Calculate status counts (include 'uploaded' as uploading for display)
            const counts = { selected: 0, uploading: 0, uploaded: 0, waiting: 0, processing: 0, completed: 0, failed: 0, skipped: 0 };
            entries.forEach(([_, info]) => {
                if (counts[info.status] !== undefined) counts[info.status]++;
            });
            
            // Update status badges
            const uploadingBadge = document.getElementById('uploadingBadge');
            const processingBadge = document.getElementById('processingBadge');
            const waitingBadge = document.getElementById('waitingBadge');
            const completedBadge = document.getElementById('completedBadge');
            const failedBadge = document.getElementById('failedBadge');
            const skippedBadge = document.getElementById('skippedBadge');
            
            const uploadingTotal = counts.selected + counts.uploading + counts.uploaded;
            uploadingBadge.style.display = uploadingTotal > 0 ? 'inline-flex' : 'none';
            document.getElementById('uploadingCount').textContent = uploadingTotal;
            
            processingBadge.style.display = counts.processing > 0 ? 'inline-flex' : 'none';
            document.getElementById('processingCount').textContent = counts.processing;
            
            waitingBadge.style.display = counts.waiting > 0 ? 'inline-flex' : 'none';
            document.getElementById('waitingCount').textContent = counts.waiting;
            
            completedBadge.style.display = counts.completed > 0 ? 'inline-flex' : 'none';
            document.getElementById('completedCount').textContent = counts.completed;
            
            failedBadge.style.display = counts.failed > 0 ? 'inline-flex' : 'none';
            document.getElementById('failedCount').textContent = counts.failed;
            
            skippedBadge.style.display = counts.skipped > 0 ? 'inline-flex' : 'none';
            document.getElementById('skippedCount').textContent = counts.skipped;
            
            // Empty state
            if (entries.length === 0) {
                container.innerHTML = '<div class="queue-empty">No tracks yet</div>';
                return;
            }
            
            // Group by status
            const groups = {
                processing: [],
                uploading: [],
                uploaded: [],
                selected: [],
                waiting: [],
                completed: [],
                failed: [],
                skipped: []
            };
            
            entries.forEach(([filename, info]) => {
                if (groups[info.status]) {
                    groups[info.status].push({ filename, ...info });
                }
            });
            
            let html = '';
            
            // For large track lists (100+), limit displayed items per section
            const MAX_DISPLAY_PER_SECTION = entries.length > 500 ? 20 : (entries.length > 100 ? 50 : 100);
            
            // Failed tracks first (most important to see)
            if (groups.failed.length > 0) {
                html += `<div class="track-list-section-header" style="color: var(--error);">
                     Failed (${groups.failed.length})
                    <button onclick="retryFailedFiles()" style="margin-left: 12px; padding: 4px 12px; background: var(--error); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Retry All</button>
                    <button onclick="clearFailedFiles()" style="margin-left: 8px; padding: 4px 12px; background: var(--bg-tertiary); color: var(--text-secondary); border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>`;
                groups.failed.forEach(track => {
                    html += renderTrackItem(track);
                });
            }
            
            // Processing tracks
            if (groups.processing.length > 0) {
                html += '<div class="track-list-section-header">Processing</div>';
                groups.processing.forEach(track => {
                    html += renderTrackItem(track);
                });
            }
            
            // Uploading tracks (combine uploading, uploaded, selected)
            const uploadingItems = [...groups.uploading, ...groups.uploaded, ...groups.selected];
            if (uploadingItems.length > 0) {
                html += `<div class="track-list-section-header">Uploading (${uploadingItems.length})</div>`;
                uploadingItems.slice(0, MAX_DISPLAY_PER_SECTION).forEach(track => {
                    html += renderTrackItem({ ...track, status: track.status === 'uploaded' ? 'uploaded' : 'uploading' });
                });
                if (uploadingItems.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${uploadingItems.length - MAX_DISPLAY_PER_SECTION} more uploading...</div>`;
                }
            }
            
            // Waiting tracks
            if (groups.waiting.length > 0) {
                html += `<div class="track-list-section-header">Waiting in Queue (${groups.waiting.length})</div>`;
                groups.waiting.slice(0, MAX_DISPLAY_PER_SECTION).forEach((track, index) => {
                    html += renderTrackItem(track, index + 1);
                });
                if (groups.waiting.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${groups.waiting.length - MAX_DISPLAY_PER_SECTION} more in queue...</div>`;
                }
            }
            
            // Completed tracks
            if (groups.completed.length > 0) {
                html += `<div class="track-list-section-header">Completed (${groups.completed.length})</div>`;
                groups.completed.slice(0, MAX_DISPLAY_PER_SECTION).forEach(track => {
                    html += renderTrackItem(track);
                });
                if (groups.completed.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${groups.completed.length - MAX_DISPLAY_PER_SECTION} more completed...</div>`;
                }
            }
            
            // Skipped tracks (already processed)
            if (groups.skipped.length > 0) {
                html += `<div class="track-list-section-header" style="color: var(--text-muted);">Skipped - Already Processed (${groups.skipped.length})</div>`;
                groups.skipped.slice(0, MAX_DISPLAY_PER_SECTION).forEach(track => {
                    html += renderTrackItem(track);
                });
                if (groups.skipped.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${groups.skipped.length - MAX_DISPLAY_PER_SECTION} more skipped...</div>`;
                }
            }
            
            container.innerHTML = html;
            lucide.createIcons();
        }

        function renderTrackItem(track, queuePosition = null) {
            const { filename, status, progress, worker } = track;
            
            let checkboxClass = status;
            let checkboxIcon = '';
            let statusLabel = '';
            let showProgress = false;
            
            switch (status) {
                case 'selected':
                case 'uploading':
                    checkboxIcon = '<i data-lucide="upload"></i>';
                    checkboxClass = 'uploading';
                    statusLabel = progress > 0 ? `${progress}%` : 'Uploading';
                    showProgress = true;  // Show progress bar for uploads too
                    break;
                case 'uploaded':
                    checkboxIcon = '<i data-lucide="check-circle"></i>';
                    checkboxClass = 'uploading';
                    statusLabel = 'Uploaded';
                    showProgress = false;
                    break;
                case 'waiting':
                    checkboxIcon = '<i data-lucide="clock"></i>';
                    statusLabel = queuePosition ? `#${queuePosition}` : 'Waiting';
                    break;
                case 'processing':
                    checkboxIcon = '<i data-lucide="loader-2"></i>';
                    statusLabel = worker ? `W${worker}` : 'Processing';
                    showProgress = true;
                    break;
                case 'completed':
                    checkboxIcon = '<i data-lucide="check"></i>';
                    checkboxClass = 'checked';
                    statusLabel = 'Done';
                    break;
                case 'failed':
                    checkboxIcon = '<i data-lucide="alert-circle"></i>';
                    checkboxClass = 'failed';
                    statusLabel = track.error ? track.error.substring(0, 30) + '...' : 'Failed';
                    break;
                case 'skipped':
                    checkboxIcon = '<i data-lucide="skip-forward"></i>';
                    checkboxClass = 'skipped';
                    statusLabel = 'Skipped';
                    break;
            }
            
            // Different progress bar color for upload (blue) vs processing (white)
            const progressColor = status === 'uploading' ? '#3b82f6' : 'var(--accent)';
            
            return `
                <div class="track-list-item">
                    <div class="track-checkbox ${checkboxClass}">${checkboxIcon}</div>
                    <span class="track-list-item-name">${escapeHtml(filename)}</span>
                    ${showProgress ? `
                        <div class="track-list-item-progress">
                            <div class="track-list-item-progress-fill" style="width: ${progress}%; background: ${progressColor}"></div>
                        </div>
                    ` : ''}
                    <span class="track-list-item-status ${status}">${statusLabel}</span>
                </div>
            `;
        }

        function syncTracksFromQueueItems(queueItems, completedTracks, failedFiles = []) {
            // Update tracks from queue items (server-side queue)
            const queueFilenames = new Set();
            const failedFilenames = new Set(failedFiles.map(f => f.filename));
            
            queueItems.forEach(item => {
                queueFilenames.add(item.filename);
                // Handle failed status from server
                const status = item.status === 'failed' ? 'failed' : 
                               item.status === 'processing' ? 'processing' : 'waiting';
                
                if (!allTracks[item.filename]) {
                    allTracks[item.filename] = { 
                        status, 
                        progress: item.progress || 0, 
                        worker: item.worker,
                        error: item.step || null
                    };
                } else {
                    allTracks[item.filename].status = status;
                    allTracks[item.filename].progress = item.progress || 0;
                    allTracks[item.filename].worker = item.worker;
                    if (item.step) allTracks[item.filename].error = item.step;
                }
            });
            
            // Mark failed files from server status
            failedFiles.forEach(failed => {
                if (allTracks[failed.filename]) {
                    allTracks[failed.filename].status = 'failed';
                    allTracks[failed.filename].error = failed.error;
                } else {
                    allTracks[failed.filename] = {
                        status: 'failed',
                        progress: 0,
                        error: failed.error
                    };
                }
            });
            
            // Mark completed tracks
            completedTracks.forEach(trackName => {
                // Find matching track (may have different key)
                const matchingKey = Object.keys(allTracks).find(key => 
                    key === trackName || 
                    key.replace(/\.mp3$/i, '') === trackName ||
                    trackName.includes(key.replace(/\.mp3$/i, ''))
                );
                
                if (matchingKey && !failedFilenames.has(matchingKey)) {
                    allTracks[matchingKey].status = 'completed';
                    allTracks[matchingKey].progress = 100;
                }
            });
            
            // Remove tracks that are no longer in queue and not completed/uploading/failed
            Object.keys(allTracks).forEach(filename => {
                const track = allTracks[filename];
                if (!queueFilenames.has(filename) && 
                    !failedFilenames.has(filename) &&
                    track.status !== 'completed' && 
                    track.status !== 'uploading' &&
                    track.status !== 'selected' &&
                    track.status !== 'failed') {
                    // Track finished or was removed - check if completed
                    const isCompleted = completedTracks.some(name => 
                        filename === name || 
                        filename.replace(/\.mp3$/i, '') === name ||
                        name.includes(filename.replace(/\.mp3$/i, ''))
                    );
                    if (isCompleted) {
                        allTracks[filename].status = 'completed';
                    }
                }
            });
            
            updateFullTrackListUI();
        }

        // Initialize workers grid
        updateWorkersUI(0, 16);
        
        // Initialize full track list
        updateFullTrackListUI();

        // Start polling on page load for multi-user visibility
        startPolling();
        startStatsPolling();

        // ===== HISTORY MODAL FUNCTIONS =====
        
        function openHistoryModal() {
            document.getElementById('historyModal').classList.add('show');
            loadHistory();
        }

        function closeHistoryModal() {
            document.getElementById('historyModal').classList.remove('show');
        }

        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeHistoryModal();
            }
        });

        // Close modal on overlay click
        document.getElementById('historyModal').addEventListener('click', (e) => {
            if (e.target.id === 'historyModal') {
                closeHistoryModal();
            }
        });

        async function loadHistory() {
            try {
                const response = await fetch('/history');
                const data = await response.json();
                
                // Update stats
                document.getElementById('historyTotal').textContent = data.stats.total;
                document.getElementById('historyCompleted').textContent = data.stats.completed;
                document.getElementById('historyFailed').textContent = data.stats.failed;
                document.getElementById('historyPending').textContent = data.stats.pending;
                
                // Update table
                const tbody = document.getElementById('historyTableBody');
                
                if (data.history.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" class="history-empty">No upload history yet</td></tr>';
                    return;
                }
                
                tbody.innerHTML = data.history.map(entry => {
                    const statusClass = entry.status.toLowerCase();
                    const typeClass = getTypeClass(entry.type);
                    const errorTooltip = entry.error ? `title="${escapeHtml(entry.error)}"` : '';
                    
                    return `
                        <tr>
                            <td style="max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(entry.filename)}">
                                ${escapeHtml(entry.filename)}
                            </td>
                            <td>
                                <span class="history-status ${statusClass}" ${errorTooltip}>
                                    ${getStatusIcon(entry.status)}
                                    ${entry.status}
                                </span>
                            </td>
                            <td>
                                <span class="history-type ${typeClass}">
                                    ${escapeHtml(entry.type || 'Unknown')}
                                </span>
                            </td>
                            <td style="color: var(--text-muted); font-size: 12px;">
                                ${escapeHtml(entry.date)}
                            </td>
                        </tr>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Error loading history:', error);
                document.getElementById('historyTableBody').innerHTML = 
                    '<tr><td colspan="4" class="history-empty">Error loading history</td></tr>';
            }
        }

        function getStatusIcon(status) {
            switch (status.toLowerCase()) {
                case 'completed':
                    return '<i data-lucide="check-circle" style="width:12px;height:12px;"></i>';
                case 'failed':
                    return '<i data-lucide="x-circle" style="width:12px;height:12px;"></i>';
                case 'processing':
                    return '<i data-lucide="loader-2" style="width:12px;height:12px;" class="spin"></i>';
                case 'skipped':
                    return '<i data-lucide="skip-forward" style="width:12px;height:12px;"></i>';
                default:
                    return '<i data-lucide="clock" style="width:12px;height:12px;"></i>';
            }
        }

        function getTypeClass(type) {
            if (!type) return '';
            const typeLower = type.toLowerCase();
            if (typeLower.includes('instrumental')) return 'instrumental';
            if (typeLower.includes('acapella')) return 'acapella';
            if (typeLower.includes('extended')) return 'extended';
            return '';
        }

        async function clearHistory() {
            if (!confirm('Are you sure you want to clear all upload history?')) {
                return;
            }
            
            try {
                await fetch('/history/clear', { method: 'POST' });
                showToast('History cleared');
                loadHistory();
            } catch (error) {
                console.error('Error clearing history:', error);
                showToast('Error clearing history');
            }
        }
    </script>
</body>
</html>
