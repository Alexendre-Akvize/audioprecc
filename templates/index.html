<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ID By Rivoli</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @font-face {
            font-family: 'ClashGrotesk';
            src: url('/static/fonts/ClashGrotesk-Variable.ttf') format('truetype');
            font-weight: 200 700;
            font-display: swap;
        }
        
        :root {
            --bg-primary: #09090b;
            --bg-secondary: #18181b;
            --bg-tertiary: #27272a;
            --bg-card: rgba(24, 24, 27, 0.8);
            --border: #27272a;
            --border-hover: #3f3f46;
            --text-primary: #fafafa;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --accent: #fafafa;
            --accent-muted: rgba(250, 250, 250, 0.1);
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --radius: 12px;
            --radius-sm: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'ClashGrotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }

        /* Subtle grid pattern */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 64px 64px;
            pointer-events: none;
            z-index: 0;
        }

        .app {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px 24px;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 48px;
            padding-bottom: 24px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-mark {
            width: 40px;
            height: 40px;
            background: var(--accent);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-mark svg {
            color: var(--bg-primary);
        }

        .logo-text {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .version {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 400; 
        }

        /* System Stats Bar */
        .stats-bar {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .stat-chip {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 100px;
            font-size: 13px;
            backdrop-filter: blur(8px);
        }

        .stat-chip svg {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
        }

        .stat-value {
            font-weight: 500;
            color: var(--text-primary);
        }

        .stat-label {
            color: var(--text-muted);
        }

        .stat-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 24px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            backdrop-filter: blur(8px);
            overflow: hidden;
        }

        .card-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title svg {
            width: 16px;
            height: 16px;
            color: var(--text-muted);
        }

        .card-body {
            padding: 24px;
        }

        /* Upload Zone */
        .upload-zone {
            border: 1px dashed var(--border);
            border-radius: var(--radius-sm);
            padding: 48px 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
        }

        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: var(--accent);
            background: var(--accent-muted);
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 16px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            color: var(--text-muted);
        }

        .upload-title {
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 6px;
        }

        .upload-subtitle {
            font-size: 13px;
            color: var(--text-muted);
        }

        .upload-actions {
            margin-top: 20px;
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 18px;
            font-size: 13px;
            font-weight: 500;
            font-family: inherit;
            border-radius: var(--radius-sm);
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn svg {
            width: 14px;
            height: 14px;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
        }

        .btn-ghost:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-full {
            width: 100%;
            padding: 14px 24px;
            font-size: 14px;
            margin-top: 20px;
        }

        /* File List */
        .file-list {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: var(--radius-sm);
            font-size: 13px;
            color: var(--text-secondary);
        }

        .file-item:hover {
            background: var(--bg-tertiary);
        }

        .file-item svg {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-count {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 12px;
        }

        .file-count-label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .file-count-value {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }

        /* Progress */
        .progress-section {
            display: none;
            margin-top: 24px;
        }

        .progress-section.active {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .progress-label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .progress-value {
            font-size: 13px;
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }

        .progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 100px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 100px;
        }

        .progress-status {
            margin-top: 12px;
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .progress-status svg {
            width: 12px;
            height: 12px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spin {
            animation: spin 1s linear infinite;
        }
        
        /* Time Estimation */
        .time-estimation {
            margin-top: 16px;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: var(--radius-sm);
        }
        
        .time-estimation-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .time-estimation-row svg {
            width: 16px;
            height: 16px;
            color: #3b82f6;
        }
        
        .time-label {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .time-value {
            font-size: 15px;
            font-weight: 600;
            color: #3b82f6;
            margin-left: auto;
            font-variant-numeric: tabular-nums;
        }
        
        .time-estimation-details {
            margin-top: 6px;
            padding-left: 24px;
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .time-estimation-elapsed {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(59, 130, 246, 0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            padding-left: 24px;
        }
        
        .elapsed-label {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .elapsed-value {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
        }

        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* Queue Card */
        .queue-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .queue-count {
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-muted);
        }

        .queue-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .queue-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            font-size: 13px;
        }

        .queue-item-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .queue-item-status.processing {
            background: var(--warning);
            animation: pulse 1s infinite;
        }

        .queue-item-status.waiting {
            background: var(--text-muted);
        }

        .queue-item-status.done {
            background: var(--success);
        }

        .queue-item-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-secondary);
        }

        .queue-item-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 100px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }

        .queue-empty {
            padding: 32px;
            text-align: center;
            color: var(--text-muted);
            font-size: 13px;
        }

        /* Track Status Summary */
        .track-status-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 500;
        }

        .status-badge svg {
            width: 12px;
            height: 12px;
        }

        .status-badge.uploading {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
        }

        .status-badge.processing {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }

        .status-badge.waiting {
            background: rgba(161, 161, 170, 0.15);
            color: var(--text-muted);
        }

        .status-badge.completed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }

        .status-badge.skipped {
            background: rgba(161, 161, 170, 0.1);
            color: var(--text-muted);
        }

        .status-badge.failed {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }

        /* Full Track List */
        .full-track-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 500px;
            overflow-y: auto;
        }

        .track-list-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            font-size: 12px;
            transition: all 0.15s ease;
        }

        .track-list-item:hover {
            background: var(--bg-tertiary);
        }

        .track-checkbox {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.15s ease;
        }

        .track-checkbox svg {
            width: 12px;
            height: 12px;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .track-checkbox.checked {
            background: var(--success);
            border-color: var(--success);
        }

        .track-checkbox.checked svg {
            color: white;
            opacity: 1;
        }

        .track-checkbox.uploading {
            border-color: #3b82f6;
        }

        .track-checkbox.uploading svg {
            color: #3b82f6;
            opacity: 1;
            animation: spin 1s linear infinite;
        }

        .track-checkbox.processing {
            border-color: var(--warning);
        }

        .track-checkbox.processing svg {
            color: var(--warning);
            opacity: 1;
            animation: spin 1s linear infinite;
        }

        .track-checkbox.waiting {
            border-color: var(--text-muted);
        }

        .track-list-item-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-secondary);
        }

        .track-list-item-status {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 100px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            font-weight: 500;
            flex-shrink: 0;
        }

        .track-list-item-status.uploading {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
        }

        .track-list-item-status.processing {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }

        .track-list-item-status.waiting {
            background: rgba(161, 161, 170, 0.15);
            color: var(--text-muted);
        }
        
        .track-list-item-status.ready_for_download {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
            font-weight: 500;
        }

        .track-list-item-status.completed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }

        .track-list-item-status.uploaded {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
        }

        .track-list-item-status.failed {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }

        .track-list-item-status.skipped {
            background: rgba(161, 161, 170, 0.1);
            color: var(--text-muted);
        }

        .track-checkbox.failed {
            border-color: var(--error);
            background: rgba(239, 68, 68, 0.1);
        }

        .track-checkbox.failed svg {
            color: var(--error);
            opacity: 1;
        }

        .track-checkbox.skipped {
            border-color: var(--text-muted);
            background: rgba(161, 161, 170, 0.1);
        }

        .track-checkbox.skipped svg {
            color: var(--text-muted);
            opacity: 1;
        }
        
        .track-checkbox.ready_for_download {
            border-color: var(--warning);
            background: rgba(245, 158, 11, 0.2);
        }

        .track-checkbox.ready_for_download svg {
            color: var(--warning);
            opacity: 1;
        }

        .track-list-item-progress {
            width: 60px;
            height: 3px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .track-list-item-progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s ease;
        }

        .track-list-section-header {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 12px 12px 6px 12px;
            margin-top: 8px;
        }

        .track-list-section-header:first-child {
            margin-top: 0;
        }

        /* Workers Card */
        .workers-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .worker-cell {
            aspect-ratio: 1;
            border-radius: var(--radius-sm);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-muted);
            transition: all 0.2s ease;
        }

        .worker-cell.active {
            background: var(--accent-muted);
            border-color: var(--accent);
            color: var(--accent);
        }

        .worker-cell.busy {
            background: rgba(245, 158, 11, 0.1);
            border-color: var(--warning);
            color: var(--warning);
        }

        /* Stats Card */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-box {
            padding: 16px;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
        }

        .stat-box-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .stat-box-header svg {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
        }

        .stat-box-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-box-value {
            font-size: 24px;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .stat-box-sub {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Results Section */
        .results-section {
            display: none;
            margin-top: 32px;
        }

        .results-section.active {
            display: block;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-title {
            font-size: 16px;
            font-weight: 600;
        }

        .results-count {
            font-size: 13px;
            color: var(--text-muted);
        }

        .track-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            margin-bottom: 12px;
            overflow: hidden;
        }

        .track-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .track-icon {
            width: 36px;
            height: 36px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .track-icon svg {
            width: 18px;
            height: 18px;
            color: var(--text-muted);
        }

        .track-info {
            flex: 1;
        }

        .track-name {
            font-size: 14px;
            font-weight: 500;
        }

        .track-meta {
            font-size: 12px;
            color: var(--text-muted);
        }

        .track-edits {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        .edit-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 20px;
            border-bottom: 1px solid var(--border);
        }

        .edit-item:last-child {
            border-bottom: none;
        }

        .edit-name {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .edit-actions {
            display: flex;
            gap: 6px;
        }

        .dl-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 500;
            font-family: inherit;
            border-radius: 6px;
            text-decoration: none;
            transition: all 0.15s ease;
        }

        .dl-btn-mp3 {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .dl-btn-mp3:hover {
            opacity: 0.9;
        }

        .dl-btn-wav {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .dl-btn-wav:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-hover);
        }
        
        /* Downloaded state for buttons */
        .dl-btn.downloaded {
            opacity: 0.6;
            background: var(--success) !important;
            color: white !important;
            border-color: var(--success) !important;
        }
        
        /* Track status badges */
        .track-status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 500;
            margin-left: 8px;
        }
        
        .track-status-badge svg {
            width: 12px;
            height: 12px;
        }
        
        .track-status-badge.ready {
            background: var(--warning);
            color: var(--bg-primary);
        }
        
        .track-status-badge.completed {
            background: var(--success);
            color: white;
        }
        
        /* Track download progress bar */
        .track-download-progress {
            height: 3px;
            background: var(--bg-tertiary);
            width: 100%;
        }
        
        .track-download-progress-bar {
            height: 100%;
            background: var(--warning);
            transition: width 0.3s ease;
        }
        
        /* Track icon states */
        .track-icon.ready {
            background: var(--warning);
        }
        
        .track-icon.ready svg {
            color: var(--bg-primary);
        }
        
        .track-icon.completed {
            background: var(--success);
        }
        
        .track-icon.completed svg {
            color: white;
        }
        
        /* Download all button */
        .btn-download-all {
            margin-left: auto;
            padding: 8px 16px;
            font-size: 12px;
        }
        
        .btn-download-all svg {
            width: 14px;
            height: 14px;
        }

        /* Log Panel */
        .log-panel {
            display: none;
            margin-top: 16px;
        }

        .log-panel.active {
            display: block;
        }

        .log-content {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 12px;
            max-height: 160px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-entry {
            color: var(--text-muted);
            padding: 2px 0;
        }

        .log-entry.success {
            color: var(--success);
        }

        .log-entry.error {
            color: var(--error);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 100px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 14px 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        /* History Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .modal-overlay.show .modal {
            transform: scale(1);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Dropbox Import Styles */
        .dropbox-warning {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 20px;
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: var(--radius-sm);
            color: var(--warning);
        }

        .dropbox-warning svg {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .dropbox-warning a {
            color: var(--accent);
            text-decoration: underline;
        }

        .dropbox-input-section {
            margin-bottom: 24px;
        }

        .dropbox-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .dropbox-input-row {
            display: flex;
            gap: 8px;
        }

        .dropbox-input {
            flex: 1;
            padding: 12px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
        }

        .dropbox-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .dropbox-input::placeholder {
            color: var(--text-muted);
        }

        .dropbox-hint {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .dropbox-file-list {
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            overflow: hidden;
        }

        .dropbox-file-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            font-size: 13px;
            font-weight: 500;
        }

        .dropbox-file-actions {
            display: flex;
            gap: 8px;
        }

        .dropbox-files-container {
            max-height: 400px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .dropbox-file-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .dropbox-file-item:last-child {
            border-bottom: none;
        }

        .dropbox-file-item:hover {
            background: var(--bg-tertiary);
        }

        .dropbox-file-item.selected {
            background: rgba(34, 197, 94, 0.1);
        }

        .dropbox-file-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.15s ease;
        }

        .dropbox-file-item.selected .dropbox-file-checkbox {
            background: var(--success);
            border-color: var(--success);
        }

        .dropbox-file-checkbox svg {
            width: 12px;
            height: 12px;
            color: white;
            opacity: 0;
        }

        .dropbox-file-item.selected .dropbox-file-checkbox svg {
            opacity: 1;
        }

        .dropbox-file-info {
            flex: 1;
            min-width: 0;
        }

        .dropbox-file-name {
            font-size: 13px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dropbox-file-path {
            font-size: 11px;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dropbox-file-size {
            font-size: 12px;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .dropbox-folder-item {
            cursor: pointer;
            background: var(--bg-tertiary);
        }

        .dropbox-folder-item:hover {
            background: var(--bg-secondary);
        }

        .dropbox-folder-icon {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--warning);
            flex-shrink: 0;
        }

        .dropbox-folder-icon svg {
            width: 18px;
            height: 18px;
        }

        .dropbox-namespace-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dropbox-namespace-btn {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: left;
        }

        .dropbox-namespace-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-hover);
        }

        .dropbox-namespace-btn.active {
            background: rgba(34, 197, 94, 0.1);
            border-color: var(--success);
        }

        .dropbox-namespace-btn svg {
            width: 20px;
            height: 20px;
            color: var(--text-muted);
        }

        .dropbox-namespace-btn.active svg {
            color: var(--success);
        }

        .dropbox-namespace-info {
            flex: 1;
        }

        .dropbox-namespace-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .dropbox-namespace-desc {
            font-size: 12px;
            color: var(--text-muted);
        }

        .dropbox-progress {
            margin-top: 24px;
            padding: 16px;
            background: var(--bg-primary);
            border-radius: var(--radius-sm);
        }

        .dropbox-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .dropbox-progress-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .btn-sm {
            padding: 4px 12px;
            font-size: 12px;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .history-table th,
        .history-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .history-table th {
            font-weight: 500;
            color: var(--text-muted);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .history-table td {
            color: var(--text-secondary);
        }

        .history-table tr:hover td {
            background: var(--bg-tertiary);
        }

        .history-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 100px;
            font-size: 11px;
            font-weight: 500;
        }

        .history-status.completed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
        }

        .history-status.failed {
            background: rgba(239, 68, 68, 0.15);
            color: var(--error);
        }

        .history-status.uploaded,
        .history-status.processing {
            background: rgba(245, 158, 11, 0.15);
            color: var(--warning);
        }

        .history-stats {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
        }

        .history-stat {
            padding: 12px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            text-align: center;
        }

        .history-stat-value {
            font-size: 20px;
            font-weight: 600;
        }

        .history-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .history-type {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }

        .history-type.instrumental {
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
        }

        .history-type.acapella {
            background: rgba(236, 72, 153, 0.15);
            color: #f472b6;
        }

        .history-type.extended {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .history-empty {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast svg {
            width: 16px;
            height: 16px;
        }

        .toast.success svg {
            color: var(--success);
        }

        /* Hidden inputs */
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Persistent Bulk Import Banner (shown when import is running) -->
    <div id="bulkImportBanner" style="display: none; position: fixed; top: 0; left: 0; right: 0; z-index: 9999; background: linear-gradient(90deg, var(--accent), #4ade80); color: #000; padding: 8px 16px; font-size: 0.9em; font-weight: 600; text-align: center; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
        <span id="bulkBannerText">ðŸ“¦ Bulk Import Running...</span>
        <span style="margin-left: 16px; font-weight: normal;" id="bulkBannerStats"></span>
    </div>
    
    <div class="app">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <div class="logo-mark">
                    <i data-lucide="audio-waveform" width="20" height="20"></i>
                </div>
                <div>
                    <div class="logo-text">ID By Rivoli</div>
                    <div class="version">{{ version_info }}</div>
                </div>
            </div>
            <div class="stats-bar" id="statsBar">
                <button class="btn btn-secondary" onclick="openHistoryModal()" style="padding: 8px 14px;">
                    <i data-lucide="history"></i>
                    History
                </button>
                <div class="stat-chip">
                    <i data-lucide="cpu"></i>
                    <span class="stat-value" id="cpuValue">--</span>
                    <span class="stat-label">CPU</span>
                </div>
                <div class="stat-chip">
                    <i data-lucide="hard-drive"></i>
                    <span class="stat-value" id="ramValue">--</span>
                    <span class="stat-label">RAM</span>
                </div>
                <div class="stat-chip" id="gpuChip" style="display: none;">
                    <div class="stat-dot"></div>
                    <span class="stat-value" id="gpuValue">H100</span>
                    <span class="stat-label" id="gpuMem">80GB</span>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-grid">
            <!-- Left Column: Upload & Results -->
            <div class="main-content">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <i data-lucide="upload-cloud"></i>
                            Upload Audio Files
                        </div>
                        <button class="btn btn-ghost" onclick="clearFiles()" id="clearBtn" style="display: none;">
                            <i data-lucide="trash-2"></i>
                            Clear
                        </button>
                    </div>
                    <div class="card-body">
                        <form id="uploadForm">
                            <div class="upload-zone" id="dropZone">
                                <div class="upload-icon">
                                    <i data-lucide="music"></i>
                                </div>
                                <div class="upload-title">Drop MP3/WAV files or folders here</div>
                                <div class="upload-subtitle">or click to browse</div>
                                <div class="upload-actions">
                                    <button type="button" class="btn btn-secondary" onclick="document.getElementById('fileInput').click()">
                                        <i data-lucide="file-audio"></i>
                                        Select Files
                                    </button>
                                    <button type="button" class="btn btn-secondary" onclick="document.getElementById('folderInput').click()">
                                        <i data-lucide="folder"></i>
                                        Select Folder
                                    </button>
                                    <button type="button" class="btn btn-secondary" onclick="openDropboxModal()" id="dropboxBtn">
                                        <i data-lucide="cloud-download"></i>
                                        Import from Dropbox
                                    </button>
                                </div>
                                <input type="file" id="fileInput" accept=".mp3,.wav" multiple>
                                <input type="file" id="folderInput" webkitdirectory directory multiple>
        </div>

                            <div id="fileListSection" style="display: none;">
                                <div class="file-count">
                                    <span class="file-count-label">Selected files</span>
                                    <span class="file-count-value" id="fileCount">0 files</span>
                                </div>
                                <div class="file-list" id="fileList"></div>
            </div>
            
                            <div class="progress-section" id="progressSection">
                                <div class="progress-header">
                                    <span class="progress-label" id="progressLabel">Uploading...</span>
                                    <span class="progress-value" id="progressValue">0%</span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progressFill"></div>
                                </div>
                                <div class="progress-status" id="progressStatus">
                                    <i data-lucide="loader-2"></i>
                                    <span id="statusText">Initializing...</span>
                                </div>
                                
                                <!-- Time Estimation Display -->
                                <div class="time-estimation" id="timeEstimation" style="display: none;">
                                    <div class="time-estimation-row">
                                        <i data-lucide="clock"></i>
                                        <span class="time-label">Estimated time remaining:</span>
                                        <span class="time-value" id="etaValue">Calculating...</span>
                                    </div>
                                    <div class="time-estimation-details">
                                        <span id="etaDetails">--</span>
                                    </div>
                                    <div class="time-estimation-elapsed">
                                        <span class="elapsed-label">Elapsed:</span>
                                        <span class="elapsed-value" id="elapsedTime">0:00</span>
                                    </div>
                                </div>
            </div>
            
                            <div class="log-panel" id="logPanel">
                                <div class="log-content" id="logContent"></div>
                            </div>

                            <button type="submit" class="btn btn-primary btn-full" id="submitBtn">
                                <i data-lucide="play"></i>
                                Start Processing
                            </button>
        </form>
                    </div>
                </div>

                <!-- Results -->
                <div class="results-section" id="resultsSection">
                    <div class="results-header">
                        <div>
                            <div class="results-title">Processed Tracks</div>
                            <div class="results-count" id="resultsCount">0 tracks ready</div>
            </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-ghost" onclick="clearResults()">
                                <i data-lucide="trash-2"></i>
                                Clear
                            </button>
                            <a href="/download_all_zip" class="btn btn-primary">
                                <i data-lucide="archive"></i>
                                Download All
                            </a>
                        </div>
                    </div>
                    <div id="resultsList"></div>
                </div>
            </div>

            <!-- Right Column: Sidebar -->
            <div class="sidebar">
                <!-- Dropbox Import Card - Always visible when active -->
                <div class="card" id="dropboxImportCard" style="display: none; border: 1px solid #6366f1; background: rgba(99, 102, 241, 0.05);">
                    <div class="card-header" style="background: rgba(99, 102, 241, 0.1); cursor: pointer;" onclick="openDropboxModal()">
                        <div class="card-title" style="color: #a5b4fc;">
                            <i data-lucide="cloud-download"></i>
                            Dropbox Import
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span class="queue-count" id="dropboxImportCount" style="background: #6366f1; color: white;">0</span>
                            <button class="btn btn-ghost btn-sm" onclick="event.stopPropagation(); stopBulkImport()" id="sidebarStopBtn" style="padding: 4px 8px;">
                                <i data-lucide="square" style="width: 12px; height: 12px;"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body" style="padding: 16px;">
                        <!-- Status -->
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                            <div id="dropboxStatusDot" style="width: 8px; height: 8px; border-radius: 50%; background: #22c55e; animation: pulse 2s infinite;"></div>
                            <span id="dropboxStatusLabel" style="font-size: 13px; color: var(--text-secondary);">Watching...</span>
                        </div>
                        
                        <!-- Progress Bar -->
                        <div style="height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden; margin-bottom: 8px;">
                            <div id="dropboxProgressBarSidebar" style="height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                        
                        <!-- Stats Grid -->
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 12px;">
                            <div style="text-align: center; padding: 8px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 16px; font-weight: 600; color: #6366f1;" id="dropboxDownloaded">0</div>
                                <div style="font-size: 10px; color: var(--text-muted);">â¬‡ï¸ DL</div>
                            </div>
                            <div style="text-align: center; padding: 8px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 16px; font-weight: 600; color: #f59e0b;" id="dropboxQueue">0</div>
                                <div style="font-size: 10px; color: var(--text-muted);">â³ Queue</div>
                            </div>
                            <div style="text-align: center; padding: 8px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 16px; font-weight: 600; color: #22c55e;" id="dropboxProcessed">0</div>
                                <div style="font-size: 10px; color: var(--text-muted);">âœ… Done</div>
                            </div>
                            <div style="text-align: center; padding: 8px; background: var(--bg-tertiary); border-radius: 6px;">
                                <div style="font-size: 16px; font-weight: 600; color: #ef4444;" id="dropboxFailed">0</div>
                                <div style="font-size: 10px; color: var(--text-muted);">âŒ Fail</div>
                            </div>
                        </div>
                        
                        <!-- Current File -->
                        <div id="dropboxCurrentFile" style="margin-top: 12px; padding: 8px; background: var(--bg-tertiary); border-radius: 6px; font-size: 11px; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            Ready to import
                        </div>
                    </div>
                </div>
                
                <!-- Quick Import Button (when no import running) -->
                <div class="card" id="dropboxQuickCard" style="cursor: pointer;" onclick="openDropboxModal()">
                    <div class="card-body" style="padding: 16px; display: flex; align-items: center; gap: 12px;">
                        <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #6366f1, #8b5cf6); border-radius: 10px; display: flex; align-items: center; justify-content: center;">
                            <i data-lucide="cloud-download" style="color: white; width: 20px; height: 20px;"></i>
                        </div>
                        <div style="flex: 1;">
                            <div style="font-size: 14px; font-weight: 500;">Import from Dropbox</div>
                            <div style="font-size: 12px; color: var(--text-muted);">Continuous sync & process</div>
                        </div>
                        <i data-lucide="chevron-right" style="color: var(--text-muted);"></i>
                    </div>
                </div>
                
                <!-- Workers -->
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <i data-lucide="boxes"></i>
                            Workers
                        </div>
                        <span class="queue-count" id="workersActive">0 / 16</span>
                    </div>
                    <div class="card-body">
                        <div class="workers-grid" id="workersGrid"></div>
                    </div>
                </div>

                <!-- Current Processing Display -->
                <div class="card" id="currentProcessingCard" style="display: none; border: 1px solid var(--accent); background: rgba(168, 255, 120, 0.05);">
                    <div class="card-header" style="background: rgba(168, 255, 120, 0.1);">
                        <div class="card-title" style="color: var(--accent);">
                            <i data-lucide="loader-2" class="spin"></i>
                            Now Processing
                        </div>
                    </div>
                    <div class="card-body" style="padding: 16px;">
                        <div id="currentProcessingInfo">
                            <div style="font-size: 1.1em; font-weight: 600; margin-bottom: 8px; color: var(--text);" id="currentTrackName">-</div>
                            <div style="font-size: 0.9em; color: var(--text-secondary); margin-bottom: 12px;" id="currentTrackStep">Waiting...</div>
                            <div style="height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden;">
                                <div id="currentTrackProgress" style="height: 100%; background: var(--accent); width: 0%; transition: width 0.3s ease;"></div>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.8em; color: var(--text-secondary);">
                                <span id="currentTrackWorker">Worker -</span>
                                <span id="currentTrackPercent">0%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Full Track List -->
                <div class="card">
                    <div class="card-header">
                        <div class="queue-header">
                            <div class="card-title">
                                <i data-lucide="list-checks"></i>
                                All Tracks
                            </div>
                            <span class="queue-count" id="totalTrackCount">0</span>
                        </div>
                    </div>
                    <div class="card-body" style="padding: 12px;">
                        <!-- Status summary -->
                        <div class="track-status-summary" id="trackStatusSummary">
                            <div class="status-badge uploading" id="uploadingBadge" style="display: none;">
                                <i data-lucide="upload"></i>
                                <span id="uploadingCount">0</span> uploading
                            </div>
                            <div class="status-badge processing" id="processingBadge" style="display: none;">
                                <i data-lucide="loader-2" class="spin"></i>
                                <span id="processingCount">0</span> processing
                            </div>
                            <div class="status-badge waiting" id="waitingBadge" style="display: none;">
                                <i data-lucide="clock"></i>
                                <span id="waitingCount">0</span> waiting
                            </div>
                            <div class="status-badge ready" id="readyBadge" style="display: none; background: rgba(245, 158, 11, 0.2); color: var(--warning);">
                                <i data-lucide="download"></i>
                                <span id="readyCount">0</span> ready
                            </div>
                            <div class="status-badge completed" id="completedBadge" style="display: none;">
                                <i data-lucide="check-circle-2"></i>
                                <span id="completedCount">0</span> done
                            </div>
                            <div class="status-badge failed" id="failedBadge" style="display: none; background: rgba(239, 68, 68, 0.2); color: var(--error);">
                                <i data-lucide="alert-circle"></i>
                                <span id="failedCount">0</span> failed
                                <button onclick="retryFailedFiles()" style="margin-left: 8px; padding: 2px 8px; background: var(--error); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Retry</button>
                            </div>
                            <div class="status-badge skipped" id="skippedBadge" style="display: none;">
                                <i data-lucide="skip-forward"></i>
                                <span id="skippedCount">0</span> skipped
                            </div>
                        </div>
                        
                        <!-- Full track list -->
                        <div class="full-track-list" id="fullTrackList">
                            <div class="queue-empty">No tracks yet</div>
                        </div>
                    </div>
                </div>

                <!-- System Stats -->
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <i data-lucide="gauge"></i>
                            System
                </div>
            </div>
                    <div class="card-body">
                        <div class="stats-grid">
                            <div class="stat-box">
                                <div class="stat-box-header">
                                    <i data-lucide="zap"></i>
                                    <span class="stat-box-label">GPU</span>
                                </div>
                                <div class="stat-box-value" id="gpuUsage">--%</div>
                                <div class="stat-box-sub" id="gpuName">Detecting...</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-box-header">
                                    <i data-lucide="database"></i>
                                    <span class="stat-box-label">Memory</span>
                                </div>
                                <div class="stat-box-value" id="memUsage">--%</div>
                                <div class="stat-box-sub" id="memAvail">-- GB available</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-box-header">
                                    <i data-lucide="hard-drive"></i>
                                    <span class="stat-box-label">Disk</span>
                                </div>
                                <div class="stat-box-value" id="diskUsage">--%</div>
                                <div class="stat-box-sub" id="diskFree">-- GB free</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-box-header">
                                    <i data-lucide="activity"></i>
                                    <span class="stat-box-label">Throughput</span>
                                </div>
                                <div class="stat-box-value" id="throughput">--</div>
                                <div class="stat-box-sub">tracks/min</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <i data-lucide="check-circle"></i>
        <span id="toastMessage">Success</span>
    </div>

    <!-- History Modal -->
    <div class="modal-overlay" id="historyModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">
                    <i data-lucide="history"></i>
                    Upload History
                </div>
                <button class="btn btn-ghost" onclick="closeHistoryModal()">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="history-stats" id="historyStats">
                    <div class="history-stat">
                        <div class="history-stat-value" id="historyTotal">0</div>
                        <div class="history-stat-label">Total</div>
                    </div>
                    <div class="history-stat">
                        <div class="history-stat-value" style="color: var(--success);" id="historyCompleted">0</div>
                        <div class="history-stat-label">Completed</div>
                    </div>
                    <div class="history-stat">
                        <div class="history-stat-value" style="color: var(--error);" id="historyFailed">0</div>
                        <div class="history-stat-label">Failed</div>
                    </div>
                    <div class="history-stat">
                        <div class="history-stat-value" style="color: var(--warning);" id="historyPending">0</div>
                        <div class="history-stat-label">Pending</div>
                    </div>
                </div>
                <div id="historyTableContainer">
                    <table class="history-table">
                        <thead>
                            <tr>
                                <th>Filename</th>
                                <th>Status</th>
                                <th>Type</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody id="historyTableBody">
                            <tr><td colspan="4" class="history-empty">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="modal-footer">
                <div style="display: flex; gap: 8px;">
                    <a href="/history/csv" class="btn btn-secondary" download>
                        <i data-lucide="download"></i>
                        Download CSV
                    </a>
                    <button class="btn btn-ghost" onclick="clearHistory()">
                        <i data-lucide="trash-2"></i>
                        Clear History
                    </button>
                </div>
                <button class="btn btn-primary" onclick="closeHistoryModal()">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Dropbox Import Modal -->
    <div class="modal-overlay" id="dropboxModal">
        <div class="modal" style="max-width: 700px;">
            <div class="modal-header">
                <h2 class="modal-title">
                    <i data-lucide="cloud-download"></i>
                    Import from Dropbox
                </h2>
                <button class="btn btn-ghost" onclick="closeDropboxModal()">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div class="modal-body">
                <div id="dropboxNotConfigured" style="display: none;">
                    <div class="dropbox-warning">
                        <i data-lucide="alert-triangle"></i>
                        <div>
                            <strong>Dropbox not configured</strong>
                            <p>Set DROPBOX_ACCESS_TOKEN in your .env file to enable Dropbox import.</p>
                            <p style="margin-top: 8px; font-size: 12px; color: var(--text-muted);">
                                Get your token at: <a href="https://www.dropbox.com/developers/apps" target="_blank">dropbox.com/developers/apps</a>
                            </p>
                        </div>
                    </div>
                </div>
                <div id="dropboxConfigured">
                    <!-- Namespace selector for team accounts -->
                    <div id="dropboxNamespaceSection" class="dropbox-input-section" style="display: none;">
                        <label class="dropbox-label">Select Dropbox Location</label>
                        <div class="dropbox-namespace-options" id="dropboxNamespaceOptions"></div>
                    </div>
                    
                    <div class="dropbox-input-section">
                        <label class="dropbox-label">Dropbox Folder Path</label>
                        <div class="dropbox-input-row">
                            <input type="text" id="dropboxFolderPath" class="dropbox-input" placeholder="/Music/Tracks or leave empty for root">
                            <button class="btn btn-secondary" onclick="listDropboxFiles()" id="dropboxListBtn">
                                <i data-lucide="search"></i>
                                Browse
                            </button>
                            <button class="btn btn-secondary" onclick="scanAllDropboxFiles()" id="dropboxScanBtn">
                                <i data-lucide="scan"></i>
                                Scan
                            </button>
                            <button class="btn btn-primary" onclick="startBulkImport()" id="dropboxBulkBtn">
                                <i data-lucide="download-cloud"></i>
                                Import All
                            </button>
                        </div>
                        <p class="dropbox-hint">Scan to preview files, or Import All to download and process entire folder</p>
                    </div>
                    
                    <!-- Bulk Import Status Panel (minimal - main display is in sidebar) -->
                    <div id="bulkImportPanel" class="dropbox-progress" style="display: none; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px; padding: 16px;">
                        <div class="dropbox-progress-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 8px; height: 8px; border-radius: 50%; background: #6366f1; animation: pulse 2s infinite;"></div>
                                <span id="bulkImportStatus" style="font-weight: 500; color: #a5b4fc;">Running</span>
                            </div>
                            <button class="btn btn-ghost btn-sm" onclick="stopBulkImport()" id="bulkStopBtn" style="display: none; color: #ef4444;">
                                <i data-lucide="square"></i> Stop Import
                            </button>
                        </div>
                        <div class="progress-bar" style="margin: 12px 0; height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden;">
                            <div class="progress-fill" id="bulkProgressBar" style="width: 0%; background: linear-gradient(90deg, #6366f1, #8b5cf6); height: 100%;"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-muted);">
                            <span id="bulkProgressText">0 / 0 files</span>
                            <span id="bulkCurrentFile"></span>
                        </div>
                        <div id="bulkStats" style="margin-top: 8px; font-size: 12px; color: var(--text-muted);"></div>
                        <p style="margin-top: 12px; font-size: 11px; color: var(--text-muted);">
                            ðŸ’¡ Status also visible in the sidebar. This import runs continuously until stopped.
                        </p>
                    </div>
                    
                    <div id="dropboxFileList" class="dropbox-file-list" style="display: none;">
                        <div class="dropbox-file-header">
                            <span id="dropboxFileCount">0 audio files found</span>
                            <div class="dropbox-file-actions">
                                <button class="btn btn-ghost btn-sm" onclick="selectAllDropboxFiles()">Select All</button>
                                <button class="btn btn-ghost btn-sm" onclick="deselectAllDropboxFiles()">Deselect All</button>
                            </div>
                        </div>
                        <div id="dropboxFiles" class="dropbox-files-container"></div>
                    </div>
                    
                    <div id="dropboxImportProgress" class="dropbox-progress" style="display: none;">
                        <div class="dropbox-progress-header">
                            <span id="dropboxProgressLabel">Importing...</span>
                            <span id="dropboxProgressValue">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="dropboxProgressFill"></div>
                        </div>
                        <div class="dropbox-progress-status" id="dropboxProgressStatus">
                            <span id="dropboxStatusText">Starting download...</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" onclick="closeDropboxModal()">Cancel</button>
                <button class="btn btn-primary" onclick="startDropboxImport()" id="dropboxImportBtn" disabled>
                    <i data-lucide="download"></i>
                    Import Selected Files
                </button>
            </div>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();
    
        let selectedFiles = [];
        let pollingInterval = null;
        let statsInterval = null;
        let numWorkers = 16;
        let processedCount = 0;
        let startTime = null;
        let isUploading = false;
        let lastResultsCount = 0;
        
        // Full track tracking system
        // Status: 'selected' | 'uploading' | 'waiting' | 'processing' | 'ready_for_download' | 'completed'
        let allTracks = {}; // { filename: { status: string, progress: number, worker: number|null } }
        
        // ==========================================================================
        // SEQUENTIAL MODE: Track individual file downloads per track
        // ==========================================================================
        let trackDownloads = {}; // { trackName: { files: {filename: downloaded}, edits: [], total: n, downloaded: n } }
        let currentDownloadingTrack = null; // Track currently being downloaded
        
        // ==========================================================================
        // TIME ESTIMATION: Track processing times for ETA calculations
        // ==========================================================================
        let trackProcessingTimes = []; // Array of processing durations in ms
        let trackStartTimes = {}; // { filename: startTimestamp } - when each track started processing
        let lastQueueSize = 0;
        let avgProcessingTime = 0; // Average time per track in ms
        const MAX_TIME_SAMPLES = 20; // Keep last 20 samples for rolling average

        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const folderInput = document.getElementById('folderInput');
        const fileList = document.getElementById('fileList');
        const fileListSection = document.getElementById('fileListSection');
        const fileCount = document.getElementById('fileCount');
        const clearBtn = document.getElementById('clearBtn');
        const submitBtn = document.getElementById('submitBtn');
        const progressSection = document.getElementById('progressSection');
        const progressFill = document.getElementById('progressFill');
        const progressValue = document.getElementById('progressValue');
        const progressLabel = document.getElementById('progressLabel');
        const statusText = document.getElementById('statusText');
        const logPanel = document.getElementById('logPanel');
        const logContent = document.getElementById('logContent');
        const resultsSection = document.getElementById('resultsSection');
        const resultsList = document.getElementById('resultsList');
        const resultsCount = document.getElementById('resultsCount');
        const workersGrid = document.getElementById('workersGrid');

        // File handling
        fileInput.addEventListener('change', (e) => handleNewFiles(Array.from(e.target.files)));
        folderInput.addEventListener('change', (e) => handleNewFiles(Array.from(e.target.files)));

        function handleNewFiles(files) {
            const audioFiles = files.filter(f => {
                const name = f.name.toLowerCase();
                return name.endsWith('.mp3') || name.endsWith('.wav');
            });
            const newFiles = [];
            audioFiles.forEach(file => {
                if (!selectedFiles.some(f => f.name === file.name && f.size === file.size)) {
                    selectedFiles.push(file);
                    newFiles.push(file);
                }
            });
            // Add to full track list as 'selected'
            if (newFiles.length > 0) {
                addTracksToList(newFiles, 'selected');
            }
            updateFileList();
        }

        function clearFiles() {
            // Remove only selected/not-yet-uploaded files from track list
            selectedFiles.forEach(file => {
                if (allTracks[file.name]?.status === 'selected') {
                    delete allTracks[file.name];
                }
            });
            selectedFiles = [];
            updateFileList();
            updateFullTrackListUI();
            fileInput.value = '';
            folderInput.value = '';
        }

        function updateFileList() {
            fileCount.textContent = `${selectedFiles.length} files`;
            fileListSection.style.display = selectedFiles.length > 0 ? 'block' : 'none';
            clearBtn.style.display = selectedFiles.length > 0 ? 'flex' : 'none';
            
            fileList.innerHTML = '';
            const limit = 20;
            selectedFiles.slice(0, limit).forEach(file => {
                    const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <i data-lucide="file-audio"></i>
                    <span class="file-name">${file.name}</span>
                `;
                fileList.appendChild(item);
            });
            
                if (selectedFiles.length > limit) {
                    const more = document.createElement('div');
                more.className = 'file-item';
                more.innerHTML = `<i data-lucide="more-horizontal"></i><span class="file-name">and ${selectedFiles.length - limit} more...</span>`;
                fileList.appendChild(more);
            }
            
            lucide.createIcons();
        }

        // Drag & Drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(event => {
            dropZone.addEventListener(event, (e) => {
            e.preventDefault();
            e.stopPropagation();
            });
        });

        ['dragenter', 'dragover'].forEach(event => {
            dropZone.addEventListener(event, () => dropZone.classList.add('dragover'));
        });

        ['dragleave', 'drop'].forEach(event => {
            dropZone.addEventListener(event, () => dropZone.classList.remove('dragover'));
        });

        dropZone.addEventListener('drop', async (e) => {
            const items = e.dataTransfer.items;
            let files = [];

            if (items) {
                const queue = [];
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry?.();
                        if (entry) queue.push(entry);
                        else {
                            const file = item.getAsFile();
                            if (file) files.push(file);
                        }
                    }
                }
                
                while (queue.length > 0) {
                    const entry = queue.shift();
                    if (entry.isFile) {
                        files.push(await new Promise(r => entry.file(r)));
                    } else if (entry.isDirectory) {
                        const entries = await new Promise(r => {
                            const reader = entry.createReader();
                            const results = [];
                            const readEntries = () => {
                                reader.readEntries(e => {
                                    if (!e.length) r(results);
                                    else { results.push(...e); readEntries(); }
                                });
                            };
                            readEntries();
                        });
                        queue.push(...entries);
                    }
                }
            } else {
                files = Array.from(e.dataTransfer.files);
            }
            
            handleNewFiles(files);
        });

        // Upload file with progress tracking using XMLHttpRequest
        // With auto_enqueue=true, files are immediately queued for analysis after upload
        // This enables parallel upload + processing for better storage efficiency
        function uploadFileWithProgress(file, fileIndex, totalFiles, autoEnqueue = true) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const formData = new FormData();
                formData.append('file', file);
                
                // Auto-enqueue: immediately add to processing queue after upload
                // This allows analysis to start while more files are still uploading
                if (autoEnqueue) {
                    formData.append('auto_enqueue', 'true');
                }
                
                // Track upload progress
                xhr.upload.addEventListener('progress', (event) => {
                    if (event.lengthComputable) {
                        const filePercent = Math.round((event.loaded / event.total) * 100);
                        
                        // Calculate overall progress: completed files + current file progress
                        const completedFilesPercent = (fileIndex / totalFiles) * 100;
                        const currentFileContribution = (filePercent / totalFiles);
                        const overallPercent = Math.round(completedFilesPercent + currentFileContribution);
                        
                        // Update main progress bar
                        progressFill.style.width = overallPercent + '%';
                        progressValue.textContent = overallPercent + '%';
                        
                        // Update status text with file-specific progress
                        const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
                        const uploadedMB = (event.loaded / (1024 * 1024)).toFixed(1);
                        // Show just the filename (not the path for folder uploads)
                        const displayName = file.name.split('/').pop().split('\\').pop();
                        statusText.textContent = `Uploading ${fileIndex + 1}/${totalFiles}: ${displayName} (${uploadedMB}/${fileSizeMB} MB - ${filePercent}%)`;
                        
                        // Update track list item progress
                        updateTrackStatus(file.name, 'uploading', filePercent);
                    }
                });
                
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            // Parse JSON response to get server's sanitized filename
                            const response = JSON.parse(xhr.responseText);
                            resolve(response);
                        } catch (e) {
                            // If not JSON, just resolve with the raw response
                            resolve({ filename: file.name });
                        }
                    } else {
                        try {
                            const errorResponse = JSON.parse(xhr.responseText);
                            reject(new Error(errorResponse.error || `Upload failed: ${xhr.status}`));
                        } catch (e) {
                            reject(new Error(`Upload failed: ${xhr.status}`));
                        }
                    }
                });
                
                xhr.addEventListener('error', () => {
                    reject(new Error('Network error during upload'));
                });
                
                xhr.addEventListener('abort', () => {
                    reject(new Error('Upload aborted'));
                });
                
                xhr.open('POST', '/upload_chunk');
                xhr.send(formData);
            });
        }

        // Configurable batch upload settings for 1000+ file handling
        const UPLOAD_BATCH_SIZE = 10;  // Number of concurrent uploads
        const ENQUEUE_BATCH_SIZE = 20; // Number of concurrent enqueue calls
        
        // Batch upload helper - uploads multiple files concurrently
        // With autoEnqueue=true (default), files are immediately queued for processing
        async function uploadBatch(files, startIdx, totalFiles, autoEnqueue = true) {
            const results = await Promise.allSettled(
                files.map((file, batchIdx) => {
                    const globalIdx = startIdx + batchIdx;
                    updateTrackStatus(file.name, 'uploading', 0);
                    return uploadFileWithProgress(file, globalIdx, totalFiles, autoEnqueue)
                        .then(result => ({ file, result, success: true }))
                        .catch(error => ({ file, error, success: false }));
                })
            );
            return results.map(r => r.status === 'fulfilled' ? r.value : { ...r.reason, success: false });
        }
        
        // Batch enqueue helper - enqueues multiple files concurrently
        async function enqueueBatch(filenames) {
            const results = await Promise.allSettled(
                filenames.map(filename => 
                    fetch('/enqueue_file', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filename })
                    }).then(r => r.ok ? r.json() : Promise.reject(new Error(`Enqueue failed: ${r.status}`)))
                )
            );
            return results;
        }

        // Form submit - full AI processing workflow
        document.getElementById('uploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            if (selectedFiles.length === 0) {
                showToast('Please select at least one file');
                return;
            }

            if (isUploading) {
                showToast('Upload in progress, please wait...');
                return;
            }

            await handleProcessUpload();
        });

        // Process upload handler - full AI processing workflow
        async function handleProcessUpload() {
            isUploading = true;
            progressSection.classList.add('active');
            logPanel.classList.add('active');
            resultsSection.classList.add('active');
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<i data-lucide="loader-2" class="spin"></i> Uploading & Processing...';
            lucide.createIcons();
            
            if (!startTime) startTime = Date.now();

            statusText.textContent = 'Uploading & queueing files...';
            progressLabel.textContent = 'Upload + Queue';

            // Start polling if not already running
            if (!pollingInterval) startPolling();
            if (!statsInterval) startStatsPolling();

            const filesToUpload = [...selectedFiles];
            const totalFiles = filesToUpload.length;
            
            // Clear selection immediately so user can add more
            selectedFiles = [];
            updateFileList();
            
            // Show batch info for large uploads
            if (totalFiles >= 100) {
                addLog(`ðŸ“¦ Starting batch upload of ${totalFiles} files with auto-queue (${UPLOAD_BATCH_SIZE} concurrent)...`, 'info');
            }

            let uploadedCount = 0;
            let failedCount = 0;
            let skippedCount = 0;
            let queuedCount = 0;
            
            // Process uploads in batches for better throughput
            // With auto_enqueue=true, each file is immediately queued for analysis after upload
            for (let i = 0; i < totalFiles; i += UPLOAD_BATCH_SIZE) {
                const batch = filesToUpload.slice(i, i + UPLOAD_BATCH_SIZE);
                const batchNum = Math.floor(i / UPLOAD_BATCH_SIZE) + 1;
                const totalBatches = Math.ceil(totalFiles / UPLOAD_BATCH_SIZE);
                
                if (totalFiles >= 50) {
                    statusText.textContent = `Uploading batch ${batchNum}/${totalBatches} (${uploadedCount}/${totalFiles} done, ${queuedCount} queued)...`;
                }
                
                // Upload batch concurrently (with auto_enqueue=true)
                const batchResults = await uploadBatch(batch, i, totalFiles);
                
                // Process results
                for (const result of batchResults) {
                    if (result.success) {
                        const serverFilename = result.result.filename || result.file.name;
                        const response = result.result;
                        uploadedCount++;
                        
                        // Update track name if it was sanitized by server
                        if (serverFilename !== result.file.name) {
                            delete allTracks[result.file.name];
                        }
                        
                        // Handle different auto-enqueue results
                        if (response.skipped) {
                            // Track was already processed - skip
                            skippedCount++;
                            allTracks[serverFilename] = { status: 'skipped', progress: 100, worker: null };
                            addLog(`â­ï¸ Skipped (already processed): ${serverFilename}`, 'info');
                        } else if (response.auto_enqueued) {
                            // File was uploaded AND queued for processing
                            queuedCount++;
                            allTracks[serverFilename] = { status: 'waiting', progress: 100, worker: null };
                        } else if (response.auto_enqueue_blocked) {
                            // Auto-enqueue was blocked due to too many pending downloads
                            allTracks[serverFilename] = { status: 'uploaded', progress: 100, worker: null };
                            addLog(`âš ï¸ Queue blocked: ${serverFilename} - too many pending tracks`, 'warning');
                        } else {
                            // File was uploaded but not auto-enqueued (fallback)
                            allTracks[serverFilename] = { status: 'uploaded', progress: 100, worker: null };
                        }
                    } else {
                        failedCount++;
                        addLog(`Failed: ${result.file?.name || 'Unknown'} - ${result.error?.message || 'Unknown error'}`, 'error');
                        removeTrackFromList(result.file?.name);
                    }
                }
                
                // Update overall progress (full 100% since upload+queue is one step now)
                const uploadProgress = Math.round((i + batch.length) / totalFiles * 100);
                progressFill.style.width = uploadProgress + '%';
                progressValue.textContent = uploadProgress + '%';
                updateFullTrackListUI();
            }
            
            // No separate enqueue phase needed - files are already queued during upload!
            
            updateFullTrackListUI();

            progressFill.style.width = '100%';
            progressValue.textContent = '100%';
            progressLabel.textContent = 'Processing';
            
            // Build status message
            let statusMsg = `${queuedCount} files queued for processing`;
            if (skippedCount > 0) {
                statusMsg += ` (${skippedCount} skipped - already processed)`;
            }
            statusText.textContent = statusMsg;
            
            if (failedCount > 0) {
                addLog(`âš ï¸ ${failedCount} files failed to upload`, 'error');
            }
            if (skippedCount > 0) {
                addLog(`â­ï¸ ${skippedCount} files skipped (already processed)`, 'info');
            }
            
            // Re-enable upload immediately - users can add more files while processing
            isUploading = false;
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i data-lucide="plus"></i> Add More Files';
            lucide.createIcons();
            
            let toastMsg = `${queuedCount} files queued`;
            if (skippedCount > 0) toastMsg += `, ${skippedCount} skipped`;
            if (failedCount > 0) toastMsg += `, ${failedCount} failed`;
            showToast(toastMsg);
        }

        // ==========================================================================
        // TIME ESTIMATION FUNCTIONS
        // ==========================================================================
        
        function formatDuration(ms) {
            if (ms < 0 || !isFinite(ms)) return '--';
            
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            if (hours > 0) {
                const remainingMinutes = minutes % 60;
                return `${hours}h ${remainingMinutes}m`;
            } else if (minutes > 0) {
                const remainingSeconds = seconds % 60;
                return `${minutes}m ${remainingSeconds}s`;
            } else {
                return `${seconds}s`;
            }
        }
        
        function updateCurrentProcessingCard(queueItems) {
            const card = document.getElementById('currentProcessingCard');
            const trackName = document.getElementById('currentTrackName');
            const trackStep = document.getElementById('currentTrackStep');
            const trackProgress = document.getElementById('currentTrackProgress');
            const trackWorker = document.getElementById('currentTrackWorker');
            const trackPercent = document.getElementById('currentTrackPercent');
            
            // Find the currently processing item(s)
            const processingItems = queueItems.filter(item => item.status === 'processing');
            
            if (processingItems.length === 0) {
                card.style.display = 'none';
                return;
            }
            
            // Show card
            if (card.style.display === 'none') {
                card.style.display = 'block';
                lucide.createIcons();
            }
            
            // Show the first processing item prominently
            const current = processingItems[0];
            trackName.textContent = current.filename || 'Unknown';
            trackStep.textContent = current.step || 'Processing...';
            trackProgress.style.width = `${current.progress || 0}%`;
            trackWorker.textContent = current.worker ? `Worker ${current.worker}` : 'Worker -';
            trackPercent.textContent = `${current.progress || 0}%`;
            
            // If multiple items are processing, show count
            if (processingItems.length > 1) {
                trackStep.textContent = `${current.step || 'Processing...'} (+${processingItems.length - 1} more)`;
                
                // Show all processing items
                const allProcessing = processingItems.map(item => 
                    `<div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--bg-tertiary); font-size: 0.85em;">
                        <span style="color: var(--text);">${item.filename || 'Unknown'}</span>
                        <span style="color: var(--text-secondary);">W${item.worker || '-'} ${item.progress || 0}%</span>
                    </div>`
                ).join('');
                
                document.getElementById('currentProcessingInfo').innerHTML = `
                    <div style="font-size: 1em; font-weight: 600; margin-bottom: 8px; color: var(--accent);">
                        ðŸŽµ ${processingItems.length} tracks processing
                    </div>
                    <div style="max-height: 200px; overflow-y: auto;">
                        ${allProcessing}
                    </div>
                `;
            } else {
                // Single item - restore original layout
                document.getElementById('currentProcessingInfo').innerHTML = `
                    <div style="font-size: 1.1em; font-weight: 600; margin-bottom: 8px; color: var(--text);" id="currentTrackName">${current.filename || 'Unknown'}</div>
                    <div style="font-size: 0.9em; color: var(--text-secondary); margin-bottom: 12px;" id="currentTrackStep">${current.step || 'Processing...'}</div>
                    <div style="height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden;">
                        <div id="currentTrackProgress" style="height: 100%; background: var(--accent); width: ${current.progress || 0}%; transition: width 0.3s ease;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 0.8em; color: var(--text-secondary);">
                        <span id="currentTrackWorker">Worker ${current.worker || '-'}</span>
                        <span id="currentTrackPercent">${current.progress || 0}%</span>
                    </div>
                `;
            }
        }
        
        function updateTimeEstimation(queueItems, completedTracks, activeWorkers) {
            const timeEstimationEl = document.getElementById('timeEstimation');
            const etaValueEl = document.getElementById('etaValue');
            const etaDetailsEl = document.getElementById('etaDetails');
            const elapsedTimeEl = document.getElementById('elapsedTime');
            
            // Update elapsed time
            if (startTime) {
                const elapsed = Date.now() - startTime;
                elapsedTimeEl.textContent = formatDuration(elapsed);
            } else {
                elapsedTimeEl.textContent = '0:00';
            }
            
            // Track processing times for tracks that just finished
            const currentProcessing = new Set(
                queueItems.filter(item => item.status === 'processing').map(item => item.filename)
            );
            
            // Record start times for new processing tracks
            currentProcessing.forEach(filename => {
                if (!trackStartTimes[filename]) {
                    trackStartTimes[filename] = Date.now();
                    console.log(`â±ï¸ Started tracking: ${filename}`);
                }
            });
            
            // Check for tracks that finished (were processing but now in completedTracks)
            Object.keys(trackStartTimes).forEach(filename => {
                const isCompleted = completedTracks.some(name => 
                    filename.includes(name) || name.includes(filename.replace(/\.mp3$/i, ''))
                );
                const stillProcessing = currentProcessing.has(filename);
                
                if (isCompleted && !stillProcessing) {
                    // Track finished - record the time
                    const duration = Date.now() - trackStartTimes[filename];
                    trackProcessingTimes.push(duration);
                    
                    // Keep only last N samples
                    if (trackProcessingTimes.length > MAX_TIME_SAMPLES) {
                        trackProcessingTimes.shift();
                    }
                    
                    // Calculate new average
                    avgProcessingTime = trackProcessingTimes.reduce((a, b) => a + b, 0) / trackProcessingTimes.length;
                    
                    console.log(`â±ï¸ Finished: ${filename} in ${formatDuration(duration)} (avg: ${formatDuration(avgProcessingTime)})`);
                    delete trackStartTimes[filename];
                }
            });
            
            // Calculate ETA
            const queueSize = queueItems.filter(item => item.status === 'waiting').length;
            const processingCount = currentProcessing.size;
            const totalPending = queueSize + processingCount;
            
            // Show/hide estimation panel
            if (totalPending > 0 || processingCount > 0) {
                timeEstimationEl.style.display = 'block';
                
                if (avgProcessingTime > 0 && activeWorkers > 0) {
                    // Parallel processing: divide by number of active workers
                    const effectiveWorkers = Math.max(1, activeWorkers);
                    const etaMs = (totalPending / effectiveWorkers) * avgProcessingTime;
                    
                    etaValueEl.textContent = formatDuration(etaMs);
                    
                    // Detailed breakdown
                    const avgPerTrack = formatDuration(avgProcessingTime);
                    let details = `${totalPending} track${totalPending !== 1 ? 's' : ''} remaining`;
                    details += ` Â· ~${avgPerTrack}/track`;
                    if (effectiveWorkers > 1) {
                        details += ` Â· ${effectiveWorkers} parallel workers`;
                    }
                    etaDetailsEl.textContent = details;
                } else if (processingCount > 0) {
                    // First track(s) still processing - estimate based on current progress
                    const processingItems = queueItems.filter(item => item.status === 'processing');
                    const avgProgress = processingItems.reduce((sum, item) => sum + (item.progress || 0), 0) / processingItems.length;
                    
                    if (avgProgress > 5) {
                        // Estimate based on current progress
                        const firstTrackStart = Object.values(trackStartTimes)[0];
                        if (firstTrackStart) {
                            const elapsed = Date.now() - firstTrackStart;
                            const estimatedTotal = elapsed / (avgProgress / 100);
                            const remaining = estimatedTotal - elapsed;
                            etaValueEl.textContent = formatDuration(remaining);
                            etaDetailsEl.textContent = `Calculating from current progress (${Math.round(avgProgress)}%)...`;
                        } else {
                            etaValueEl.textContent = 'Calculating...';
                            etaDetailsEl.textContent = `${totalPending} track${totalPending !== 1 ? 's' : ''} remaining`;
                        }
                    } else {
                        etaValueEl.textContent = 'Calculating...';
                        etaDetailsEl.textContent = `${totalPending} track${totalPending !== 1 ? 's' : ''} remaining Â· Processing first track...`;
                    }
                } else {
                    etaValueEl.textContent = 'Calculating...';
                    etaDetailsEl.textContent = `${totalPending} track${totalPending !== 1 ? 's' : ''} waiting`;
                }
            } else {
                timeEstimationEl.style.display = 'none';
            }
        }

        function startPolling() {
            if (pollingInterval) return; // Already polling
            console.log('ðŸ”„ Starting main polling...');
            
            pollingInterval = setInterval(async () => {
                try {
                    const res = await fetch('/status');
                    const status = await res.json();
                    
                    // Debug: log queue items count
                    if (status.queue_items && status.queue_items.length > 0) {
                        console.log(`ðŸ“Š Queue items: ${status.queue_items.length}`, status.queue_items.slice(0, 3));
                    }

                    numWorkers = status.num_workers || 16;
                    const activeWorkers = status.active_workers || 0;
                    updateWorkersUI(activeWorkers, numWorkers);

                    // Update logs
                    if (status.logs?.length > 0) {
                        logContent.innerHTML = status.logs.slice(-50).map(log => 
                            `<div class="log-entry">${escapeHtml(log)}</div>`
                        ).join('');
                        logContent.scrollTop = logContent.scrollHeight;
                    }

                    // Get list of completed track names from results
                    const completedTracks = (status.results || []).map(r => r.original);
                    
                    // Get failed files from server status
                    const failedFiles = status.failed_files || [];
                    
                    // Sync full track list with server queue items (including failed files)
                    syncTracksFromQueueItems(status.queue_items || [], completedTracks, failedFiles);
                    
                    // Update "Now Processing" card
                    updateCurrentProcessingCard(status.queue_items || []);
                    
                    // Update time estimation
                    updateTimeEstimation(status.queue_items || [], completedTracks, activeWorkers);

                    // Always update results if there are new ones
                    if (status.results?.length > 0 && status.results.length !== lastResultsCount) {
                        displayResults(status.results);
                        lastResultsCount = status.results.length;
                    }

                    // Update status text based on state
                    if (status.state === 'processing') {
                        progressLabel.textContent = 'Processing';
                        let statusMsg = status.current_step || 'Processing...';
                        if (status.current_filename) {
                            statusMsg += ` - ${status.current_filename}`;
                        }
                        if (status.queue_size > 0) {
                            statusMsg += ` (${status.queue_size} in queue)`;
                        }
                        statusText.textContent = statusMsg;
                    } else if (status.state === 'idle') {
                        if (status.queue_size > 0) {
                            statusText.textContent = `${status.queue_size} tracks waiting...`;
                        } else {
                            progressLabel.textContent = 'Ready';
                            statusText.textContent = 'Ready for new files';
                        }
                    } else if (status.state === 'error') {
                        statusText.textContent = 'Error: ' + status.error;
                    }
                } catch (e) {
                    console.error('Polling error:', e);
                }
            }, 1000);
        }

        function startStatsPolling() {
            const updateStats = async () => {
                try {
                    const res = await fetch('/system_stats');
                    const stats = await res.json();

                    document.getElementById('cpuValue').textContent = stats.cpu.percent + '%';
                    document.getElementById('ramValue').textContent = stats.memory.used_percent + '%';

                    if (stats.gpu.available) {
                        document.getElementById('gpuChip').style.display = 'flex';
                        document.getElementById('gpuValue').textContent = stats.gpu.name.split(' ').pop();
                        document.getElementById('gpuMem').textContent = stats.gpu.memory_gb + 'GB';
                        document.getElementById('gpuUsage').textContent = stats.gpu.memory_used_percent + '%';
                        document.getElementById('gpuName').textContent = stats.gpu.name;
                    }

                    document.getElementById('memUsage').textContent = stats.memory.used_percent + '%';
                    document.getElementById('memAvail').textContent = stats.memory.available_gb + ' GB available';
                    document.getElementById('diskUsage').textContent = stats.disk.used_percent + '%';
                    document.getElementById('diskFree').textContent = stats.disk.free_gb + ' GB free';

                    // Estimate throughput
                    if (startTime && processedCount > 0) {
                        const elapsed = (Date.now() - startTime) / 60000;
                        const rate = Math.round(processedCount / elapsed);
                        document.getElementById('throughput').textContent = rate || '--';
                    }
                } catch (e) {}
            };
            
            updateStats();
            statsInterval = setInterval(updateStats, 2000);
        }

        function updateWorkersUI(active, total) {
            document.getElementById('workersActive').textContent = `${active} / ${total}`;
            workersGrid.innerHTML = '';
            
            for (let i = 0; i < total; i++) {
                const cell = document.createElement('div');
                cell.className = 'worker-cell' + (i < active ? ' busy' : '');
                cell.textContent = i + 1;
                workersGrid.appendChild(cell);
            }
        }

        function updateQueueUI(queueItems) {
            const queueList = document.getElementById('queueList');
            const items = queueItems || [];
            
            document.getElementById('queueCount').textContent = items.length;
            
            if (items.length === 0) {
                queueList.innerHTML = '<div class="queue-empty">No tracks in queue</div>';
                return;
            }
            
            let html = '';
            const maxDisplay = 10;
            
            items.slice(0, maxDisplay).forEach((item, index) => {
                const isProcessing = item.status === 'processing';
                const statusClass = isProcessing ? 'processing' : 'waiting';
                const progress = item.progress || 0;
                const step = item.step || (isProcessing ? 'Processing...' : 'Waiting...');
                const workerInfo = item.worker ? `W${item.worker}` : '';
                
                html += `
                    <div class="queue-item" style="flex-direction: column; align-items: stretch; gap: 8px;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div class="queue-item-status ${statusClass}"></div>
                            <span class="queue-item-name" style="flex: 1;">${escapeHtml(item.filename)}</span>
                            ${workerInfo ? `<span class="queue-item-badge">${workerInfo}</span>` : ''}
                        </div>
                        ${isProcessing ? `
                            <div style="display: flex; align-items: center; gap: 8px; padding-left: 20px;">
                                <div style="flex: 1; height: 3px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden;">
                                    <div style="width: ${progress}%; height: 100%; background: var(--accent); transition: width 0.3s;"></div>
                                </div>
                                <span style="font-size: 11px; color: var(--text-muted); min-width: 35px;">${progress}%</span>
                            </div>
                            <div style="font-size: 11px; color: var(--text-muted); padding-left: 20px;">${escapeHtml(step)}</div>
                        ` : `
                            <div style="font-size: 11px; color: var(--text-muted); padding-left: 20px;">#${index + 1} in queue</div>
                        `}
                    </div>
                `;
            });
            
            if (items.length > maxDisplay) {
                html += `<div class="queue-item"><span class="queue-item-name" style="text-align:center;width:100%;color:var(--text-muted)">+${items.length - maxDisplay} more in queue</span></div>`;
            }
            
            queueList.innerHTML = html;
        }

        // Download with retry logic
        async function downloadWithRetry(url, filename, maxRetries = 3) {
            let lastError = null;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    showToast(`Downloading ${filename}...`);
                    
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            throw new Error('File not found (404) - may have expired');
                        }
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const blob = await response.blob();
                    const downloadUrl = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(downloadUrl);
                    document.body.removeChild(a);
                    
                    showToast(`Downloaded: ${filename}`);
                    return true;
                    
                } catch (error) {
                    lastError = error;
                    console.error(`Download attempt ${attempt}/${maxRetries} failed:`, error);
                    
                    if (attempt < maxRetries) {
                        showToast(`Retry ${attempt}/${maxRetries} for ${filename}...`);
                        // Wait before retry (exponential backoff: 1s, 2s, 4s)
                        await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt - 1)));
                    }
                }
            }
            
            // All retries failed
            showToast(`Download failed: ${filename} - ${lastError?.message || 'Unknown error'}`);
            console.error(`All ${maxRetries} download attempts failed for ${filename}:`, lastError);
            return false;
        }

        function handleDownload(event, url, filename) {
            event.preventDefault();
            downloadWithRetry(url, filename);
        }
        
        // ==========================================================================
        // SEQUENTIAL MODE: Tracked download functions
        // ==========================================================================
        
        async function handleTrackedDownload(event, url, filename, trackName) {
            event.preventDefault();
            
            console.log(`ðŸ“¥ handleTrackedDownload called:`);
            console.log(`   URL: ${url}`);
            console.log(`   Filename: ${filename}`);
            console.log(`   TrackName: ${trackName}`);
            console.log(`   trackDownloads keys:`, Object.keys(trackDownloads));
            
            // Check if already downloaded
            if (trackDownloads[trackName]?.files[filename]) {
                showToast(`${filename} already downloaded`);
                return;
            }
            
            const success = await downloadWithRetry(url, filename);
            
            if (success && trackDownloads[trackName]) {
                // Mark file as downloaded
                trackDownloads[trackName].files[filename] = true;
                trackDownloads[trackName].downloaded++;
                
                console.log(`âœ… Downloaded: ${filename} for ${trackName}`);
                console.log(`   Progress: ${trackDownloads[trackName].downloaded}/${trackDownloads[trackName].total}`);
                
                // Check if all files are downloaded
                const trackData = trackDownloads[trackName];
                if (trackData.downloaded === trackData.total) {
                    showToast(`ðŸŽ‰ All files downloaded for: ${trackName}`);
                    
                    // Update track status to completed
                    const trackKey = Object.keys(allTracks).find(k => k.includes(trackName));
                    if (trackKey) {
                        allTracks[trackKey].status = 'completed';
                    }
                    
                    // Track will be auto-deleted by backend since all files downloaded
                }
                
                // Refresh the results display to update UI
                const statusRes = await fetch('/status');
                const status = await statusRes.json();
                if (status.results?.length > 0) {
                    displayResults(status.results);
                }
            }
        }
        
        async function downloadAllForTrack(trackName) {
            const trackData = trackDownloads[trackName];
            if (!trackData) {
                showToast('Track not found');
                return;
            }
            
            showToast(`Downloading all files for: ${trackName}...`);
            
            // Get list of files not yet downloaded
            const pendingFiles = Object.entries(trackData.files)
                .filter(([file, downloaded]) => !downloaded)
                .map(([file]) => file);
            
            if (pendingFiles.length === 0) {
                showToast('All files already downloaded!');
                return;
            }
            
            // Download each file sequentially
            for (const filename of pendingFiles) {
                // Find the corresponding edit and URL
                const edit = trackData.edits.find(e => 
                    filename === e.name + '.mp3' || filename === e.name + '.wav'
                );
                
                if (edit) {
                    const url = filename.endsWith('.mp3') ? edit.mp3 : edit.wav;
                    
                    const success = await downloadWithRetry(url, filename);
                    
                    if (success) {
                        // Mark file as downloaded
                        trackData.files[filename] = true;
                        trackData.downloaded++;
                        
                        console.log(`âœ… Downloaded: ${filename} (${trackData.downloaded}/${trackData.total})`);
                    } else {
                        console.error(`âŒ Failed to download: ${filename}`);
                    }
                    
                    // Small delay between downloads to avoid overwhelming the browser
                    await new Promise(r => setTimeout(r, 200));
                }
            }
            
            // Check if all files are now downloaded
            if (trackData.downloaded === trackData.total) {
                showToast(`ðŸŽ‰ All files downloaded for: ${trackName} - Track cleaned up`);
                
                // Update track status to completed
                const trackKey = Object.keys(allTracks).find(k => k.includes(trackName));
                if (trackKey) {
                    allTracks[trackKey].status = 'completed';
                }
            } else {
                const remaining = trackData.total - trackData.downloaded;
                showToast(`Downloaded. ${remaining} files remaining for: ${trackName}`);
            }
            
            // Refresh the results display
            const statusRes = await fetch('/status');
            const status = await statusRes.json();
            if (status.results?.length > 0) {
                displayResults(status.results);
            }
        }

        function displayResults(results) {
            processedCount = results.length;
            
            // Count tracks by download status
            let readyCount = 0;
            let completedCount = 0;
            
            results.forEach(track => {
                const trackData = trackDownloads[track.original];
                if (trackData && trackData.downloaded === trackData.total) {
                    completedCount++;
                } else {
                    readyCount++;
                }
            });
            
            resultsCount.textContent = `${readyCount} ready for download, ${completedCount} completed`;
            resultsList.innerHTML = '';
            
            results.forEach(track => {
                const card = document.createElement('div');
                card.className = 'track-card';
                const trackName = track.original;
                
                // Initialize download tracking for this track if not exists
                if (!trackDownloads[trackName]) {
                    const files = {};
                    track.edits.forEach(edit => {
                        files[edit.name + '.mp3'] = false;
                        files[edit.name + '.wav'] = false;
                    });
                    trackDownloads[trackName] = {
                        files: files,
                        edits: track.edits,
                        total: track.edits.length * 2, // MP3 + WAV for each edit
                        downloaded: 0
                    };
                }
                
                const trackData = trackDownloads[trackName];
                const isFullyDownloaded = trackData.downloaded === trackData.total;
                const downloadProgress = Math.round((trackData.downloaded / trackData.total) * 100);
                
                // Update allTracks status based on download status
                if (allTracks[trackName + '.mp3']) {
                    allTracks[trackName + '.mp3'].status = isFullyDownloaded ? 'completed' : 'ready_for_download';
                }
                
                let editsHtml = track.edits.map(edit => {
                    const mp3Filename = edit.name + '.mp3';
                    const wavFilename = edit.name + '.wav';
                    const mp3Downloaded = trackData.files[mp3Filename] || false;
                    const wavDownloaded = trackData.files[wavFilename] || false;
                    
                    return `
                        <div class="edit-item">
                            <span class="edit-name">${escapeHtml(edit.name)}</span>
                            <div class="edit-actions">
                                <a href="${edit.mp3}" class="dl-btn dl-btn-mp3 ${mp3Downloaded ? 'downloaded' : ''}" 
                                   onclick="handleTrackedDownload(event, '${edit.mp3}', '${escapeHtml(mp3Filename)}', '${escapeHtml(trackName)}')">
                                   MP3 ${mp3Downloaded ? 'âœ“' : ''}
                                </a>
                                <a href="${edit.wav}" class="dl-btn dl-btn-wav ${wavDownloaded ? 'downloaded' : ''}" 
                                   onclick="handleTrackedDownload(event, '${edit.wav}', '${escapeHtml(wavFilename)}', '${escapeHtml(trackName)}')">
                                   WAV ${wavDownloaded ? 'âœ“' : ''}
                                </a>
                            </div>
                        </div>
                    `;
                }).join('');

                // Build status badge and download all button
                const statusBadge = isFullyDownloaded 
                    ? '<span class="track-status-badge completed"><i data-lucide="check-circle"></i> Completed</span>'
                    : `<span class="track-status-badge ready"><i data-lucide="download"></i> ${trackData.downloaded}/${trackData.total} downloaded</span>`;
                
                const downloadAllBtn = isFullyDownloaded 
                    ? ''
                    : `<button class="btn btn-primary btn-download-all" onclick="downloadAllForTrack('${escapeHtml(trackName)}')">
                         <i data-lucide="download"></i> Download All
                       </button>`;

                card.innerHTML = `
                    <div class="track-header">
                        <div class="track-icon ${isFullyDownloaded ? 'completed' : 'ready'}">
                            <i data-lucide="${isFullyDownloaded ? 'check-circle' : 'disc-3'}"></i>
                        </div>
                        <div class="track-info">
                            <div class="track-name">${escapeHtml(track.original)}</div>
                            <div class="track-meta">${track.edits.length} versions Â· ${statusBadge}</div>
                        </div>
                        ${downloadAllBtn}
                    </div>
                    ${!isFullyDownloaded ? `
                        <div class="track-download-progress">
                            <div class="track-download-progress-bar" style="width: ${downloadProgress}%"></div>
                        </div>
                    ` : ''}
                    <div class="track-edits">${editsHtml}</div>
                `;
                
                resultsList.appendChild(card);
            });

            lucide.createIcons();
            resultsSection.classList.add('active');
            updateFullTrackListUI();
        }

        function resetForNewUpload() {
            isUploading = false;
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i data-lucide="play"></i> Start Processing';
            lucide.createIcons();
            selectedFiles = [];
            updateFileList();
            fileInput.value = '';
            folderInput.value = '';
        }

        function addLog(message, type = '') {
            const entry = document.createElement('div');
            entry.className = 'log-entry' + (type ? ' ' + type : '');
            entry.textContent = message;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            document.getElementById('toastMessage').textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        async function clearResults() {
            try {
                await fetch('/clear_results', { method: 'POST' });
                resultsList.innerHTML = '';
                resultsCount.textContent = '0 tracks ready';
                lastResultsCount = 0;
                processedCount = 0;
                startTime = null;
                logContent.innerHTML = '';
                
                // Clear the full track list
                allTracks = {};
                updateFullTrackListUI();
                
                // Clear time estimation tracking
                trackProcessingTimes = [];
                trackStartTimes = {};
                avgProcessingTime = 0;
                trackDownloads = {};
                document.getElementById('timeEstimation').style.display = 'none';
                
                showToast('Results cleared');
            } catch (e) {
                console.error('Clear error:', e);
            }
        }

        // Retry failed files - re-queue them for processing
        async function retryFailedFiles(specificFiles = null) {
            try {
                const body = specificFiles ? { filenames: specificFiles } : {};
                const response = await fetch('/retry_failed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const result = await response.json();
                
                if (result.retried > 0) {
                    // Update local track status to 'waiting' for retried files
                    (result.filenames || []).forEach(filename => {
                        if (allTracks[filename]) {
                            allTracks[filename].status = 'waiting';
                            allTracks[filename].progress = 0;
                            allTracks[filename].error = null;
                        }
                    });
                    updateFullTrackListUI();
                    showToast(`ðŸ”„ ${result.retried} fichier(s) remis en file d'attente`);
                } else {
                    showToast('Aucun fichier en Ã©chec Ã  rÃ©essayer');
                }
            } catch (e) {
                console.error('Retry failed:', e);
                showToast('Erreur lors de la tentative de rÃ©essai');
            }
        }

        // Clear failed files from the list without retrying
        async function clearFailedFiles(specificFiles = null) {
            try {
                const body = specificFiles ? { filenames: specificFiles } : {};
                const response = await fetch('/clear_failed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                const result = await response.json();
                
                if (result.cleared > 0) {
                    // Remove failed files from local track list
                    Object.keys(allTracks).forEach(filename => {
                        if (allTracks[filename].status === 'failed') {
                            if (!specificFiles || specificFiles.includes(filename)) {
                                delete allTracks[filename];
                            }
                        }
                    });
                    updateFullTrackListUI();
                    showToast(`ðŸ—‘ï¸ ${result.cleared} fichier(s) effacÃ©(s)`);
                } else {
                    showToast('Aucun fichier en Ã©chec Ã  effacer');
                }
            } catch (e) {
                console.error('Clear failed:', e);
                showToast('Erreur lors de la suppression');
            }
        }

        // Reset stuck processing items - use when items are stuck in "processing" state
        async function resetStuckItems() {
            try {
                const response = await fetch('/reset_stuck_items', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const result = await response.json();
                if (result.reset > 0) {
                    // Reset local state for these items
                    result.filenames.forEach(filename => {
                        if (allTracks[filename]) {
                            allTracks[filename].status = 'waiting';
                            allTracks[filename].progress = 0;
                            allTracks[filename].worker = null;
                        }
                    });
                    updateFullTrackListUI();
                    showToast(`ðŸ”„ ${result.reset} item(s) remis en file d'attente`);
                } else {
                    showToast('Aucun Ã©lÃ©ment bloquÃ© Ã  rÃ©initialiser');
                }
            } catch (e) {
                console.error('Reset stuck items error:', e);
                showToast('Erreur lors de la rÃ©initialisation');
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Track list management functions
        function addTracksToList(files, status = 'selected') {
            files.forEach(file => {
                const name = typeof file === 'string' ? file : file.name;
                if (!allTracks[name]) {
                    allTracks[name] = { status, progress: 0, worker: null };
                }
            });
            updateFullTrackListUI();
        }

        function updateTrackStatus(filename, status, progress = null, worker = null) {
            if (allTracks[filename]) {
                allTracks[filename].status = status;
                if (progress !== null) allTracks[filename].progress = progress;
                if (worker !== null) allTracks[filename].worker = worker;
            }
            updateFullTrackListUI();
        }

        function removeTrackFromList(filename) {
            delete allTracks[filename];
            updateFullTrackListUI();
        }

        function updateFullTrackListUI() {
            const container = document.getElementById('fullTrackList');
            const entries = Object.entries(allTracks);
            
            // Update total count
            document.getElementById('totalTrackCount').textContent = entries.length;
            
            // Calculate status counts (include 'uploaded' as uploading, 'ready_for_download' as separate)
            const counts = { selected: 0, uploading: 0, uploaded: 0, waiting: 0, processing: 0, ready_for_download: 0, completed: 0, failed: 0, skipped: 0 };
            entries.forEach(([_, info]) => {
                if (counts[info.status] !== undefined) counts[info.status]++;
            });
            
            // Update status badges
            const uploadingBadge = document.getElementById('uploadingBadge');
            const processingBadge = document.getElementById('processingBadge');
            const waitingBadge = document.getElementById('waitingBadge');
            const completedBadge = document.getElementById('completedBadge');
            const failedBadge = document.getElementById('failedBadge');
            const skippedBadge = document.getElementById('skippedBadge');
            const readyBadge = document.getElementById('readyBadge');
            
            const uploadingTotal = counts.selected + counts.uploading + counts.uploaded;
            uploadingBadge.style.display = uploadingTotal > 0 ? 'inline-flex' : 'none';
            document.getElementById('uploadingCount').textContent = uploadingTotal;
            
            processingBadge.style.display = counts.processing > 0 ? 'inline-flex' : 'none';
            document.getElementById('processingCount').textContent = counts.processing;
            
            waitingBadge.style.display = counts.waiting > 0 ? 'inline-flex' : 'none';
            document.getElementById('waitingCount').textContent = counts.waiting;
            
            // Ready for download badge (new!)
            if (readyBadge) {
                readyBadge.style.display = counts.ready_for_download > 0 ? 'inline-flex' : 'none';
                document.getElementById('readyCount').textContent = counts.ready_for_download;
            }
            
            completedBadge.style.display = counts.completed > 0 ? 'inline-flex' : 'none';
            document.getElementById('completedCount').textContent = counts.completed;
            
            failedBadge.style.display = counts.failed > 0 ? 'inline-flex' : 'none';
            document.getElementById('failedCount').textContent = counts.failed;
            
            skippedBadge.style.display = counts.skipped > 0 ? 'inline-flex' : 'none';
            document.getElementById('skippedCount').textContent = counts.skipped;
            
            // Empty state
            if (entries.length === 0) {
                container.innerHTML = '<div class="queue-empty">No tracks yet</div>';
                return;
            }
            
            // Group by status
            const groups = {
                processing: [],
                uploading: [],
                uploaded: [],
                selected: [],
                waiting: [],
                ready_for_download: [],
                completed: [],
                failed: [],
                skipped: []
            };
            
            entries.forEach(([filename, info]) => {
                if (groups[info.status]) {
                    groups[info.status].push({ filename, ...info });
                }
            });
            
            let html = '';
            
            // For large track lists (100+), limit displayed items per section
            const MAX_DISPLAY_PER_SECTION = entries.length > 500 ? 20 : (entries.length > 100 ? 50 : 100);
            
            // Failed tracks first (most important to see)
            if (groups.failed.length > 0) {
                html += `<div class="track-list-section-header" style="color: var(--error);">
                    âŒ Failed (${groups.failed.length})
                    <button onclick="retryFailedFiles()" style="margin-left: 12px; padding: 4px 12px; background: var(--error); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Retry All</button>
                    <button onclick="clearFailedFiles()" style="margin-left: 8px; padding: 4px 12px; background: var(--bg-tertiary); color: var(--text-secondary); border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Clear</button>
                </div>`;
                groups.failed.forEach(track => {
                    html += renderTrackItem(track);
                });
            }
            
            // Processing tracks
            if (groups.processing.length > 0) {
                // Show warning if more items are processing than workers (indicates stuck items)
                const isStuck = groups.processing.length > numWorkers;
                html += `<div class="track-list-section-header"${isStuck ? ' style="color: var(--warning);"' : ''}>
                    ${isStuck ? 'âš ï¸' : ''} Processing (${groups.processing.length}/${numWorkers} workers)
                    ${isStuck ? `<button onclick="resetStuckItems()" style="margin-left: 12px; padding: 4px 12px; background: var(--warning); color: black; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset Stuck</button>` : ''}
                </div>`;
                groups.processing.forEach(track => {
                    html += renderTrackItem(track);
                });
            }
            
            // Uploading tracks (combine uploading, uploaded, selected)
            const uploadingItems = [...groups.uploading, ...groups.uploaded, ...groups.selected];
            if (uploadingItems.length > 0) {
                html += `<div class="track-list-section-header">Uploading (${uploadingItems.length})</div>`;
                uploadingItems.slice(0, MAX_DISPLAY_PER_SECTION).forEach(track => {
                    html += renderTrackItem({ ...track, status: track.status === 'uploaded' ? 'uploaded' : 'uploading' });
                });
                if (uploadingItems.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${uploadingItems.length - MAX_DISPLAY_PER_SECTION} more uploading...</div>`;
                }
            }
            
            // Waiting tracks
            if (groups.waiting.length > 0) {
                html += `<div class="track-list-section-header">Waiting in Queue (${groups.waiting.length})</div>`;
                groups.waiting.slice(0, MAX_DISPLAY_PER_SECTION).forEach((track, index) => {
                    html += renderTrackItem(track, index + 1);
                });
                if (groups.waiting.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${groups.waiting.length - MAX_DISPLAY_PER_SECTION} more in queue...</div>`;
                }
            }
            
            // Ready for download tracks (NEW - between waiting and completed)
            if (groups.ready_for_download.length > 0) {
                html += `<div class="track-list-section-header" style="color: var(--warning);">ðŸ“¥ Ready for Download (${groups.ready_for_download.length})</div>`;
                groups.ready_for_download.slice(0, MAX_DISPLAY_PER_SECTION).forEach(track => {
                    html += renderTrackItem(track);
                });
                if (groups.ready_for_download.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${groups.ready_for_download.length - MAX_DISPLAY_PER_SECTION} more ready...</div>`;
                }
            }
            
            // Completed tracks
            if (groups.completed.length > 0) {
                html += `<div class="track-list-section-header">Completed (${groups.completed.length})</div>`;
                groups.completed.slice(0, MAX_DISPLAY_PER_SECTION).forEach(track => {
                    html += renderTrackItem(track);
                });
                if (groups.completed.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${groups.completed.length - MAX_DISPLAY_PER_SECTION} more completed...</div>`;
                }
            }
            
            // Skipped tracks (already processed)
            if (groups.skipped.length > 0) {
                html += `<div class="track-list-section-header" style="color: var(--text-muted);">Skipped - Already Processed (${groups.skipped.length})</div>`;
                groups.skipped.slice(0, MAX_DISPLAY_PER_SECTION).forEach(track => {
                    html += renderTrackItem(track);
                });
                if (groups.skipped.length > MAX_DISPLAY_PER_SECTION) {
                    html += `<div class="track-list-item" style="justify-content:center;color:var(--text-muted);">+${groups.skipped.length - MAX_DISPLAY_PER_SECTION} more skipped...</div>`;
                }
            }
            
            container.innerHTML = html;
            lucide.createIcons();
        }

        function renderTrackItem(track, queuePosition = null) {
            const { filename, status, progress, worker } = track;
            
            let checkboxClass = status;
            let checkboxIcon = '';
            let statusLabel = '';
            let showProgress = false;
            
            switch (status) {
                case 'selected':
                case 'uploading':
                    checkboxIcon = '<i data-lucide="upload"></i>';
                    checkboxClass = 'uploading';
                    statusLabel = progress > 0 ? `${progress}%` : 'Uploading';
                    showProgress = true;  // Show progress bar for uploads too
                    break;
                case 'uploaded':
                    checkboxIcon = '<i data-lucide="check-circle"></i>';
                    checkboxClass = 'uploading';
                    statusLabel = 'Uploaded';
                    showProgress = false;
                    break;
                case 'waiting':
                    checkboxIcon = '<i data-lucide="clock"></i>';
                    statusLabel = queuePosition ? `#${queuePosition}` : 'Waiting';
                    break;
                case 'processing':
                    checkboxIcon = '<i data-lucide="loader-2"></i>';
                    statusLabel = worker ? `W${worker}` : 'Processing';
                    showProgress = true;
                    break;
                case 'ready_for_download':
                    checkboxIcon = '<i data-lucide="download"></i>';
                    checkboxClass = 'ready_for_download';
                    statusLabel = 'Ready to Download';
                    break;
                case 'completed':
                    checkboxIcon = '<i data-lucide="check"></i>';
                    checkboxClass = 'checked';
                    statusLabel = 'Downloaded âœ“';
                    break;
                case 'failed':
                    checkboxIcon = '<i data-lucide="alert-circle"></i>';
                    checkboxClass = 'failed';
                    statusLabel = track.error ? track.error.substring(0, 30) + '...' : 'Failed';
                    break;
                case 'skipped':
                    checkboxIcon = '<i data-lucide="skip-forward"></i>';
                    checkboxClass = 'skipped';
                    statusLabel = 'Skipped';
                    break;
            }
            
            // Different progress bar color for upload (blue) vs processing (white)
            const progressColor = status === 'uploading' ? '#3b82f6' : 'var(--accent)';
            
            return `
                <div class="track-list-item">
                    <div class="track-checkbox ${checkboxClass}">${checkboxIcon}</div>
                    <span class="track-list-item-name">${escapeHtml(filename)}</span>
                    ${showProgress ? `
                        <div class="track-list-item-progress">
                            <div class="track-list-item-progress-fill" style="width: ${progress}%; background: ${progressColor}"></div>
                        </div>
                    ` : ''}
                    <span class="track-list-item-status ${status}">${statusLabel}</span>
                </div>
            `;
        }

        function syncTracksFromQueueItems(queueItems, completedTracks, failedFiles = []) {
            // Update tracks from queue items (server-side queue)
            const queueFilenames = new Set();
            const failedFilenames = new Set(failedFiles.map(f => f.filename));
            
            queueItems.forEach(item => {
                queueFilenames.add(item.filename);
                // Handle failed status from server
                const status = item.status === 'failed' ? 'failed' : 
                               item.status === 'processing' ? 'processing' : 'waiting';
                
                if (!allTracks[item.filename]) {
                    allTracks[item.filename] = { 
                        status, 
                        progress: item.progress || 0, 
                        worker: item.worker,
                        error: item.step || null
                    };
                } else {
                    allTracks[item.filename].status = status;
                    allTracks[item.filename].progress = item.progress || 0;
                    allTracks[item.filename].worker = item.worker;
                    if (item.step) allTracks[item.filename].error = item.step;
                }
            });
            
            // Mark failed files from server status
            failedFiles.forEach(failed => {
                if (allTracks[failed.filename]) {
                    allTracks[failed.filename].status = 'failed';
                    allTracks[failed.filename].error = failed.error;
                } else {
                    allTracks[failed.filename] = {
                        status: 'failed',
                        progress: 0,
                        error: failed.error
                    };
                }
            });
            
            // Mark tracks that finished processing as "ready_for_download" (not "completed")
            // They only become "completed" after ALL files are downloaded
            completedTracks.forEach(trackName => {
                // Find matching track (may have different key)
                const matchingKey = Object.keys(allTracks).find(key => 
                    key === trackName || 
                    key.replace(/\.mp3$/i, '') === trackName ||
                    trackName.includes(key.replace(/\.mp3$/i, ''))
                );
                
                if (matchingKey && !failedFilenames.has(matchingKey)) {
                    // Check if all files have been downloaded for this track
                    const trackData = trackDownloads[trackName];
                    if (trackData && trackData.downloaded === trackData.total) {
                        // All files downloaded - mark as completed
                        allTracks[matchingKey].status = 'completed';
                    } else {
                        // Still has files to download - mark as ready_for_download
                        allTracks[matchingKey].status = 'ready_for_download';
                    }
                    allTracks[matchingKey].progress = 100;
                }
            });
            
            // Remove tracks that are no longer in queue and not completed/uploading/failed/ready_for_download
            Object.keys(allTracks).forEach(filename => {
                const track = allTracks[filename];
                if (!queueFilenames.has(filename) && 
                    !failedFilenames.has(filename) &&
                    track.status !== 'completed' && 
                    track.status !== 'ready_for_download' &&
                    track.status !== 'uploading' &&
                    track.status !== 'selected' &&
                    track.status !== 'failed') {
                    // Track finished or was removed - check if in results
                    const isInResults = completedTracks.some(name => 
                        filename === name || 
                        filename.replace(/\.mp3$/i, '') === name ||
                        name.includes(filename.replace(/\.mp3$/i, ''))
                    );
                    if (isInResults) {
                        // Check download status
                        const trackData = trackDownloads[filename.replace(/\.mp3$/i, '')];
                        if (trackData && trackData.downloaded === trackData.total) {
                            allTracks[filename].status = 'completed';
                        } else {
                            allTracks[filename].status = 'ready_for_download';
                        }
                    }
                }
            });
            
            updateFullTrackListUI();
        }

        // Initialize workers grid
        updateWorkersUI(0, 16);
        
        // Initialize full track list
        updateFullTrackListUI();

        // Start polling on page load for multi-user visibility
        startPolling();
        startStatsPolling();

        // ===== HISTORY MODAL FUNCTIONS =====
        
        function openHistoryModal() {
            document.getElementById('historyModal').classList.add('show');
            loadHistory();
        }

        function closeHistoryModal() {
            document.getElementById('historyModal').classList.remove('show');
        }

        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeHistoryModal();
            }
        });

        // Close modal on overlay click
        document.getElementById('historyModal').addEventListener('click', (e) => {
            if (e.target.id === 'historyModal') {
                closeHistoryModal();
            }
        });

        async function loadHistory() {
            try {
                const response = await fetch('/history');
                const data = await response.json();
                
                // Update stats
                document.getElementById('historyTotal').textContent = data.stats.total;
                document.getElementById('historyCompleted').textContent = data.stats.completed;
                document.getElementById('historyFailed').textContent = data.stats.failed;
                document.getElementById('historyPending').textContent = data.stats.pending;
                
                // Update table
                const tbody = document.getElementById('historyTableBody');
                
                if (data.history.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" class="history-empty">No upload history yet</td></tr>';
                    return;
                }
                
                tbody.innerHTML = data.history.map(entry => {
                    const statusClass = entry.status.toLowerCase();
                    const typeClass = getTypeClass(entry.type);
                    const errorTooltip = entry.error ? `title="${escapeHtml(entry.error)}"` : '';
                    
                    return `
                        <tr>
                            <td style="max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(entry.filename)}">
                                ${escapeHtml(entry.filename)}
                            </td>
                            <td>
                                <span class="history-status ${statusClass}" ${errorTooltip}>
                                    ${getStatusIcon(entry.status)}
                                    ${entry.status}
                                </span>
                            </td>
                            <td>
                                <span class="history-type ${typeClass}">
                                    ${escapeHtml(entry.type || 'Unknown')}
                                </span>
                            </td>
                            <td style="color: var(--text-muted); font-size: 12px;">
                                ${escapeHtml(entry.date)}
                            </td>
                        </tr>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Error loading history:', error);
                document.getElementById('historyTableBody').innerHTML = 
                    '<tr><td colspan="4" class="history-empty">Error loading history</td></tr>';
            }
        }

        function getStatusIcon(status) {
            switch (status.toLowerCase()) {
                case 'completed':
                    return '<i data-lucide="check-circle" style="width:12px;height:12px;"></i>';
                case 'failed':
                    return '<i data-lucide="x-circle" style="width:12px;height:12px;"></i>';
                case 'processing':
                    return '<i data-lucide="loader-2" style="width:12px;height:12px;" class="spin"></i>';
                case 'skipped':
                    return '<i data-lucide="skip-forward" style="width:12px;height:12px;"></i>';
                default:
                    return '<i data-lucide="clock" style="width:12px;height:12px;"></i>';
            }
        }

        function getTypeClass(type) {
            if (!type) return '';
            const typeLower = type.toLowerCase();
            if (typeLower.includes('instrumental')) return 'instrumental';
            if (typeLower.includes('acapella')) return 'acapella';
            if (typeLower.includes('extended')) return 'extended';
            return '';
        }

        async function clearHistory() {
            if (!confirm('Are you sure you want to clear all upload history?')) {
                return;
            }
            
            try {
                await fetch('/history/clear', { method: 'POST' });
                showToast('History cleared');
                loadHistory();
            } catch (error) {
                console.error('Error clearing history:', error);
                showToast('Error clearing history');
            }
        }

        // ===== DROPBOX IMPORT FUNCTIONS =====
        
        let dropboxFiles = [];
        let dropboxFolders = [];
        let selectedDropboxFiles = new Set();
        let currentDropboxImportId = null;
        let dropboxPollingInterval = null;
        let currentDropboxNamespace = '';
        let dropboxSharedFolders = [];
        
        async function openDropboxModal() {
            const modal = document.getElementById('dropboxModal');
            modal.classList.add('show');
            
            // Check if Dropbox is configured
            try {
                const response = await fetch('/dropbox/configured');
                const data = await response.json();
                
                if (data.configured) {
                    document.getElementById('dropboxConfigured').style.display = 'block';
                    document.getElementById('dropboxNotConfigured').style.display = 'none';
                    
                    // Load namespaces for team accounts
                    await loadDropboxNamespaces();
                } else {
                    document.getElementById('dropboxConfigured').style.display = 'none';
                    document.getElementById('dropboxNotConfigured').style.display = 'block';
                }
            } catch (error) {
                console.error('Error checking Dropbox config:', error);
            }
            
            lucide.createIcons();
        }
        
        async function loadDropboxNamespaces() {
            try {
                const response = await fetch('/dropbox/namespaces');
                const data = await response.json();
                
                if (!response.ok) {
                    console.error('Error loading namespaces:', data.error);
                    return;
                }
                
                const namespaceSection = document.getElementById('dropboxNamespaceSection');
                const optionsContainer = document.getElementById('dropboxNamespaceOptions');
                optionsContainer.innerHTML = '';
                
                const namespaces = data.namespaces || [];
                dropboxSharedFolders = data.shared_folders || [];
                
                // IMPORTANT: For team accounts, always set the root namespace to access team folder contents
                // Find the team_root namespace first, fallback to any available namespace
                const teamRootNs = namespaces.find(ns => ns.type === 'team_root');
                const homeNs = namespaces.find(ns => ns.type === 'home');
                
                // Default to team_root for team accounts (needed to see subfolder contents)
                if (teamRootNs) {
                    currentDropboxNamespace = teamRootNs.id;
                    console.log('ðŸ“¦ Using team root namespace:', teamRootNs.id);
                } else if (namespaces.length > 0) {
                    currentDropboxNamespace = namespaces[0].id;
                    console.log('ðŸ“¦ Using default namespace:', namespaces[0].id);
                }
                
                // Show namespace section if we have team namespaces or shared folders
                if (namespaces.length > 1 || dropboxSharedFolders.length > 0) {
                    namespaceSection.style.display = 'block';
                    
                    // Add namespace options - default to team_root for team folders
                    namespaces.forEach(ns => {
                        const btn = document.createElement('div');
                        // For team accounts, default to team_root namespace
                        const isActive = teamRootNs ? (ns.type === 'team_root') : (ns.type === 'home');
                        btn.className = 'dropbox-namespace-btn' + (isActive ? ' active' : '');
                        btn.dataset.namespaceId = ns.id;
                        btn.innerHTML = `
                            <i data-lucide="${ns.type === 'home' ? 'user' : 'users'}"></i>
                            <div class="dropbox-namespace-info">
                                <div class="dropbox-namespace-name">${ns.name}</div>
                                <div class="dropbox-namespace-desc">${ns.type === 'home' ? 'Your personal files' : 'Team shared content'}</div>
                            </div>
                        `;
                        btn.addEventListener('click', () => selectDropboxNamespace(ns.id, btn));
                        optionsContainer.appendChild(btn);
                    });
                    
                    // Add shared/team folders section
                    if (dropboxSharedFolders.length > 0) {
                        const teamFolders = dropboxSharedFolders.filter(f => f.is_team_folder || f.is_inside_team_folder);
                        if (teamFolders.length > 0) {
                            const divider = document.createElement('div');
                            divider.style.cssText = 'font-size: 12px; color: var(--text-muted); margin-top: 8px; padding: 8px 0; border-top: 1px solid var(--border);';
                            divider.textContent = 'Team Folders (click to browse):';
                            optionsContainer.appendChild(divider);
                            
                            teamFolders.forEach(folder => {
                                const btn = document.createElement('div');
                                btn.className = 'dropbox-namespace-btn';
                                btn.innerHTML = `
                                    <i data-lucide="folder"></i>
                                    <div class="dropbox-namespace-info">
                                        <div class="dropbox-namespace-name">${folder.name}</div>
                                        <div class="dropbox-namespace-desc">Team folder</div>
                                    </div>
                                `;
                                btn.addEventListener('click', () => {
                                    document.getElementById('dropboxFolderPath').value = '/' + folder.name;
                                    listDropboxFiles();
                                });
                                optionsContainer.appendChild(btn);
                            });
                        }
                    }
                } else {
                    namespaceSection.style.display = 'none';
                }
                
                lucide.createIcons();
                
            } catch (error) {
                console.error('Error loading namespaces:', error);
            }
        }
        
        function selectDropboxNamespace(namespaceId, btnElement) {
            currentDropboxNamespace = namespaceId;
            
            // Update UI
            document.querySelectorAll('.dropbox-namespace-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            btnElement.classList.add('active');
            
            // Clear current folder listing
            document.getElementById('dropboxFileList').style.display = 'none';
            document.getElementById('dropboxFolderPath').value = '';
        }
        
        function closeDropboxModal() {
            document.getElementById('dropboxModal').classList.remove('show');
            
            // Clear state
            dropboxFiles = [];
            dropboxFolders = [];
            dropboxSharedFolders = [];
            selectedDropboxFiles.clear();
            currentDropboxNamespace = '';
            document.getElementById('dropboxFileList').style.display = 'none';
            document.getElementById('dropboxImportProgress').style.display = 'none';
            document.getElementById('dropboxImportBtn').disabled = true;
            document.getElementById('dropboxFolderPath').value = '';
            document.getElementById('dropboxNamespaceSection').style.display = 'none';
            
            // Stop polling if running
            if (dropboxPollingInterval) {
                clearInterval(dropboxPollingInterval);
                dropboxPollingInterval = null;
            }
        }
        
        // Close Dropbox modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDropboxModal();
            }
        });
        
        // Close modal on overlay click
        document.getElementById('dropboxModal').addEventListener('click', (e) => {
            if (e.target.id === 'dropboxModal') {
                closeDropboxModal();
            }
        });
        
        async function listDropboxFiles() {
            const folderPath = document.getElementById('dropboxFolderPath').value.trim();
            const listBtn = document.getElementById('dropboxListBtn');
            const fileListSection = document.getElementById('dropboxFileList');
            
            listBtn.disabled = true;
            listBtn.innerHTML = '<i data-lucide="loader-2" class="spin"></i> Loading...';
            lucide.createIcons();
            
            try {
                const response = await fetch('/dropbox/list', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        folder_path: folderPath,
                        namespace_id: currentDropboxNamespace 
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    showToast(data.error || 'Error listing files', 'error');
                    return;
                }
                
                dropboxFiles = data.files;
                dropboxFolders = data.folders || [];
                selectedDropboxFiles.clear();
                
                // Update counts
                const folderCount = data.total_folders || 0;
                const fileCount = data.total_files || 0;
                let countText = '';
                if (folderCount > 0) countText += `${folderCount} folders`;
                if (folderCount > 0 && fileCount > 0) countText += ', ';
                if (fileCount > 0) countText += `${fileCount} audio files`;
                if (!countText) countText = 'Empty folder';
                document.getElementById('dropboxFileCount').textContent = countText;
                
                // Render folders and files
                const filesContainer = document.getElementById('dropboxFiles');
                filesContainer.innerHTML = '';
                
                // Show current path with back button
                if (folderPath) {
                    const backItem = document.createElement('div');
                    backItem.className = 'dropbox-file-item dropbox-folder-item';
                    backItem.innerHTML = `
                        <div class="dropbox-folder-icon">
                            <i data-lucide="arrow-left"></i>
                        </div>
                        <div class="dropbox-file-info">
                            <div class="dropbox-file-name">..</div>
                            <div class="dropbox-file-path">Go back</div>
                        </div>
                    `;
                    backItem.addEventListener('click', () => {
                        const parentPath = folderPath.split('/').slice(0, -1).join('/');
                        document.getElementById('dropboxFolderPath').value = parentPath;
                        listDropboxFiles();
                    });
                    filesContainer.appendChild(backItem);
                }
                
                // Render folders first
                dropboxFolders.forEach((folder) => {
                    const item = document.createElement('div');
                    item.className = 'dropbox-file-item dropbox-folder-item';
                    item.innerHTML = `
                        <div class="dropbox-folder-icon">
                            <i data-lucide="folder"></i>
                        </div>
                        <div class="dropbox-file-info">
                            <div class="dropbox-file-name">${folder.name}</div>
                            <div class="dropbox-file-path">${folder.path}</div>
                        </div>
                        <div class="dropbox-file-size">
                            <i data-lucide="chevron-right"></i>
                        </div>
                    `;
                    item.addEventListener('click', () => {
                        document.getElementById('dropboxFolderPath').value = folder.path;
                        listDropboxFiles();
                    });
                    filesContainer.appendChild(item);
                });
                
                // Render files
                if (dropboxFiles.length === 0 && dropboxFolders.length === 0) {
                    filesContainer.innerHTML = '<div style="padding: 32px; text-align: center; color: var(--text-muted);">No audio files or folders found</div>';
                } else {
                    dropboxFiles.forEach((file, index) => {
                        const item = document.createElement('div');
                        item.className = 'dropbox-file-item';
                        item.dataset.index = index;
                        item.innerHTML = `
                            <div class="dropbox-file-checkbox">
                                <i data-lucide="check"></i>
                            </div>
                            <div class="dropbox-file-info">
                                <div class="dropbox-file-name">${file.name}</div>
                                <div class="dropbox-file-path">${file.path}</div>
                            </div>
                            <div class="dropbox-file-size">${file.size_mb} MB</div>
                        `;
                        item.addEventListener('click', () => toggleDropboxFile(index));
                        filesContainer.appendChild(item);
                    });
                }
                
                fileListSection.style.display = 'block';
                lucide.createIcons();
                updateDropboxImportButton();
                
            } catch (error) {
                console.error('Error listing Dropbox files:', error);
                showToast('Error connecting to Dropbox', 'error');
            } finally {
                listBtn.disabled = false;
                listBtn.innerHTML = '<i data-lucide="search"></i> Browse';
                lucide.createIcons();
            }
        }
        
        let scanEventSource = null;
        
        async function scanAllDropboxFiles() {
            const folderPath = document.getElementById('dropboxFolderPath').value.trim();
            const scanBtn = document.getElementById('dropboxScanBtn');
            const listBtn = document.getElementById('dropboxListBtn');
            const fileListSection = document.getElementById('dropboxFileList');
            const filesContainer = document.getElementById('dropboxFiles');
            
            // Close any existing scan
            if (scanEventSource) {
                scanEventSource.close();
                scanEventSource = null;
            }
            
                            scanBtn.disabled = false;
            listBtn.disabled = true;
            scanBtn.innerHTML = '<i data-lucide="square" style="fill: currentColor;"></i> Stop Scan';
            scanBtn.onclick = stopDropboxScan;
            lucide.createIcons();
            
            // Reset state
            dropboxFiles = [];
            dropboxFolders = [];
            selectedDropboxFiles.clear();
            
            fileListSection.style.display = 'block';
            filesContainer.innerHTML = '<div style="padding: 16px; text-align: center; color: var(--text-muted);"><i data-lucide="loader-2" class="spin" style="width: 24px; height: 24px;"></i><br>Scanning Dropbox for audio files...</div>';
            document.getElementById('dropboxFileCount').textContent = 'Scanning...';
            lucide.createIcons();
            
            try {
                const url = '/dropbox/scan_all' + (folderPath ? `?folder_path=${encodeURIComponent(folderPath)}` : '');
                scanEventSource = new EventSource(url);
                
                let totalSize = 0;
                let isFirstFile = true;
                
                scanEventSource.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    
                    if (data.error) {
                        showToast(data.error, 'error');
                        scanEventSource.close();
                        scanEventSource = null;
                        resetScanButton();
                        return;
                    }
                    
                    if (data.status === 'info' || data.status === 'scanning') {
                        // Status message
                        console.log('Scan status:', data.message);
                    } else if (data.status === 'progress') {
                        // Progress update
                        document.getElementById('dropboxFileCount').textContent = 
                            `Found ${data.count} files (${data.size_mb} MB) - scanning...`;
                    } else if (data.status === 'complete') {
                        // Scan complete
                        document.getElementById('dropboxFileCount').textContent = 
                            `Found ${data.total_files} audio files (${data.total_size_mb.toFixed(1)} MB total)`;
                        showToast(`Scan complete! Found ${data.total_files} audio files`, 'success');
                        scanEventSource.close();
                        scanEventSource = null;
                        resetScanButton();
                        updateDropboxImportButton();
                    } else if (data.type === 'file') {
                        // New file found - add to list
                        if (isFirstFile) {
                            filesContainer.innerHTML = '';
                            isFirstFile = false;
                        }
                        
                        dropboxFiles.push(data);
                        totalSize += data.size_mb;
                        
                        const index = data.index;
                        const item = document.createElement('div');
                        item.className = 'dropbox-file-item';
                        item.dataset.index = index;
                        item.innerHTML = `
                            <div class="dropbox-file-checkbox">
                                <input type="checkbox" id="dropbox-file-${index}">
                            </div>
                            <div class="dropbox-file-info">
                                <div class="dropbox-file-name">${data.name}</div>
                                <div class="dropbox-file-path">${data.folder || '/'}</div>
                            </div>
                            <div class="dropbox-file-size">${data.size_mb} MB</div>
                        `;
                        item.addEventListener('click', (e) => {
                            if (e.target.type !== 'checkbox') {
                                toggleDropboxFile(index);
                            }
                        });
                        filesContainer.appendChild(item);
                        
                        // Update count
                        document.getElementById('dropboxFileCount').textContent = 
                            `Found ${dropboxFiles.length} files (${totalSize.toFixed(1)} MB) - scanning...`;
                        
                        // Auto-scroll to show new file
                        filesContainer.scrollTop = filesContainer.scrollHeight;
                    }
                };
                
                scanEventSource.onerror = function(error) {
                    console.error('Scan error:', error);
                    if (dropboxFiles.length === 0) {
                        filesContainer.innerHTML = '<div style="padding: 32px; text-align: center; color: var(--text-muted);">No MP3 or WAV files found</div>';
                    }
                    scanEventSource.close();
                    scanEventSource = null;
                    resetScanButton();
                };
                
            } catch (error) {
                console.error('Error scanning Dropbox:', error);
                showToast('Error scanning Dropbox', 'error');
                resetScanButton();
            }
            
            function resetScanButton() {
                scanBtn.disabled = false;
                listBtn.disabled = false;
                scanBtn.innerHTML = '<i data-lucide="scan"></i> Scan';
                scanBtn.onclick = scanAllDropboxFiles;
                lucide.createIcons();
            }
        }
        
        function stopDropboxScan() {
            if (scanEventSource) {
                scanEventSource.close();
                scanEventSource = null;
                document.getElementById('dropboxScanBtn').disabled = false;
                document.getElementById('dropboxListBtn').disabled = false;
                document.getElementById('dropboxScanBtn').innerHTML = '<i data-lucide="scan"></i> Scan';
                lucide.createIcons();
            }
        }
        
        // =============================================================================
        // BULK IMPORT FUNCTIONS
        // =============================================================================
        
        let bulkImportPolling = null;
        
        async function startBulkImport() {
            const folderPath = document.getElementById('dropboxFolderPath').value.trim();
            
            if (!confirm(`ðŸš€ BULK IMPORT\n\nThis will import audio files from "${folderPath || 'your entire Dropbox'}":\n\nâ€¢ Auto-SKIP banned tracks (Remix, Bootleg, Mashup, etc.)\nâ€¢ Clean titles (replace DJ names â†’ ID By Rivoli)\nâ€¢ Process with all workers\nâ€¢ DELETE from Dropbox when done\n\nâš ï¸ Files will be REMOVED from Dropbox!\n(Skipped + Processed = Deleted)\n\nContinue?`)) {
                return;
            }
            
            try {
                const response = await fetch('/dropbox/bulk_import/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder_path: folderPath })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    showToast(data.error || 'Failed to start bulk import', 'error');
                    return;
                }
                
                showToast('Bulk import started!', 'success');
                showBulkImportPanel();
                startBulkImportPolling();
                
            } catch (error) {
                console.error('Error starting bulk import:', error);
                showToast('Error starting bulk import', 'error');
            }
        }
        
        async function stopBulkImport() {
            try {
                const response = await fetch('/dropbox/bulk_import/stop', {
                    method: 'POST'
                });
                
                const data = await response.json();
                showToast(data.message || 'Stop requested', 'info');
                
            } catch (error) {
                console.error('Error stopping bulk import:', error);
            }
        }
        
        function showBulkImportPanel() {
            document.getElementById('bulkImportPanel').style.display = 'block';
            document.getElementById('bulkStopBtn').style.display = 'inline-flex';
            // Show sidebar card, hide quick button
            document.getElementById('dropboxImportCard').style.display = 'block';
            document.getElementById('dropboxQuickCard').style.display = 'none';
            lucide.createIcons();
        }
        
        function hideBulkImportPanel() {
            // Show quick button, hide import card when stopped
            document.getElementById('dropboxImportCard').style.display = 'none';
            document.getElementById('dropboxQuickCard').style.display = 'block';
            lucide.createIcons();
        }
        
        function startBulkImportPolling() {
            if (bulkImportPolling) {
                clearInterval(bulkImportPolling);
            }
            
            // Poll immediately
            updateBulkImportStatus();
            
            // Then poll every 2 seconds
            bulkImportPolling = setInterval(updateBulkImportStatus, 2000);
        }
        
        async function updateBulkImportStatus() {
            try {
                const response = await fetch('/dropbox/bulk_import/status');
                const data = await response.json();
                
                const panel = document.getElementById('bulkImportPanel');
                const statusEl = document.getElementById('bulkImportStatus');
                const progressBar = document.getElementById('bulkProgressBar');
                const progressText = document.getElementById('bulkProgressText');
                const currentFile = document.getElementById('bulkCurrentFile');
                const stats = document.getElementById('bulkStats');
                const stopBtn = document.getElementById('bulkStopBtn');
                
                // Sidebar card elements
                const sidebarCard = document.getElementById('dropboxImportCard');
                const quickCard = document.getElementById('dropboxQuickCard');
                
                // Show/hide sidebar cards based on import status
                if (data.active || (data.status && data.status !== 'idle')) {
                    sidebarCard.style.display = 'block';
                    quickCard.style.display = 'none';
                    panel.style.display = 'block';
                } else {
                    sidebarCard.style.display = 'none';
                    quickCard.style.display = 'block';
                }
                
                // Update status text
                const queueSize = data.queue_size || 0;
                const statusLabels = {
                    'idle': 'No import running',
                    'starting': 'Starting...',
                    'scanning': 'ðŸ” Scanning Dropbox...',
                    'downloading': `â¬‡ï¸ Downloading... (buffer: ${queueSize}/200)`,
                    'separating': `ðŸŽµ Processing... (buffer: ${queueSize}/200)`,
                    'processing': `âš™ï¸ Processing... (buffer: ${queueSize}/200)`,
                    'watching': `ðŸ‘€ Watching for new files...`,
                    'stopping': 'â¸ï¸ Stopping...',
                    'stopped': 'â¹ï¸ Stopped',
                    'complete': `âœ… Complete! ${data.processed || 0} processed`,
                    'error': 'âŒ Error'
                };
                statusEl.textContent = statusLabels[data.status] || data.status;
                
                // Update progress bar
                const total = data.total_found || 0;
                const processed = data.processed || 0;
                const downloaded = data.downloaded || 0;
                const failed = data.failed || 0;
                const skipped = data.skipped || 0;
                const percent = total > 0 ? Math.round((processed / total) * 100) : 0;
                progressBar.style.width = `${percent}%`;
                
                // Update text
                if (data.status === 'scanning') {
                    progressText.textContent = `Found ${data.total_found} audio files...`;
                } else {
                    progressText.textContent = `${processed} / ${total} files processed`;
                }
                
                // Current file
                if (data.current_file) {
                    let statusIcon = 'â¬‡ï¸';
                    if (data.status === 'separating') statusIcon = 'ðŸŽµ';
                    else if (data.status === 'downloading') statusIcon = 'â¬‡ï¸';
                    else if (data.status === 'processing') statusIcon = 'âš™ï¸';
                    else if (data.status === 'watching') statusIcon = 'ðŸ‘€';
                    currentFile.textContent = `${statusIcon} ${data.current_file}`;
                } else {
                    currentFile.textContent = '';
                }
                
                // Stats
                let statsText = [];
                if (downloaded > 0) statsText.push(`â¬‡ï¸ ${downloaded}`);
                if (processed > 0) statsText.push(`âœ… ${processed}`);
                if (skipped > 0) statsText.push(`â­ï¸ ${skipped}`);
                if (failed > 0) statsText.push(`âŒ ${failed}`);
                if (queueSize > 0) statsText.push(`ðŸ“‹ ${queueSize} queue`);
                if (data.duration_seconds) {
                    const mins = Math.floor(data.duration_seconds / 60);
                    const secs = data.duration_seconds % 60;
                    statsText.push(`â±ï¸ ${mins}m ${secs}s`);
                }
                stats.textContent = statsText.join(' | ');
                
                // ===== UPDATE SIDEBAR CARD =====
                // Status label with color
                const statusDot = document.getElementById('dropboxStatusDot');
                const statusLabel = document.getElementById('dropboxStatusLabel');
                const sidebarProgress = document.getElementById('dropboxProgressBarSidebar');
                
                // Status colors
                const statusColors = {
                    'scanning': '#f59e0b',
                    'downloading': '#6366f1',
                    'processing': '#8b5cf6',
                    'watching': '#22c55e',
                    'stopped': '#ef4444',
                    'error': '#ef4444'
                };
                statusDot.style.background = statusColors[data.status] || '#22c55e';
                statusDot.style.animation = data.active ? 'pulse 2s infinite' : 'none';
                
                // Short status labels for sidebar
                const shortLabels = {
                    'idle': 'Ready',
                    'starting': 'Starting...',
                    'scanning': 'Scanning...',
                    'downloading': 'Downloading...',
                    'processing': 'Processing...',
                    'watching': 'Watching for files...',
                    'stopped': 'Stopped',
                    'complete': 'Complete',
                    'error': 'Error'
                };
                statusLabel.textContent = shortLabels[data.status] || data.status;
                
                // Sidebar progress
                sidebarProgress.style.width = `${percent}%`;
                
                // Stats numbers
                document.getElementById('dropboxDownloaded').textContent = downloaded;
                document.getElementById('dropboxQueue').textContent = queueSize;
                document.getElementById('dropboxProcessed').textContent = processed;
                document.getElementById('dropboxFailed').textContent = failed;
                document.getElementById('dropboxImportCount').textContent = total;
                
                // Current file in sidebar
                const sidebarCurrentFile = document.getElementById('dropboxCurrentFile');
                if (data.current_file) {
                    sidebarCurrentFile.textContent = data.current_file;
                } else if (data.status === 'watching') {
                    sidebarCurrentFile.textContent = 'ðŸ‘€ Watching for new files...';
                } else {
                    sidebarCurrentFile.textContent = 'Ready to import';
                }
                
                // Update top banner (optional - can remove if sidebar is enough)
                const banner = document.getElementById('bulkImportBanner');
                if (banner) {
                    banner.style.display = 'none'; // Hide banner, sidebar is enough
                    document.body.style.paddingTop = '0';
                }
                
                // Show/hide stop buttons
                stopBtn.style.display = data.active ? 'inline-flex' : 'none';
                document.getElementById('sidebarStopBtn').style.display = data.active ? 'inline-flex' : 'none';
                
                // Handle completion/stop - keep showing card but update status
                if (!data.active && data.status !== 'idle') {
                    if (data.status === 'stopped') {
                        showToast('Bulk import stopped.', 'info');
                        // Hide card after a delay
                        setTimeout(() => {
                            sidebarCard.style.display = 'none';
                            quickCard.style.display = 'block';
                        }, 3000);
                    } else if (data.status === 'error') {
                        showToast(`Bulk import error: ${data.error}`, 'error');
                    }
                    // Note: Don't show "complete" toast for continuous mode - it keeps watching
                    
                    // Keep polling less frequently
                    if (bulkImportPolling) {
                        clearInterval(bulkImportPolling);
                        bulkImportPolling = null;
                    }
                }
                
                lucide.createIcons();
                
            } catch (error) {
                console.error('Error fetching bulk import status:', error);
            }
        }
        
        // Check for active bulk import on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ðŸš€ Page loaded, initializing...');
            
            // ALWAYS start main polling immediately to show tracks
            startPolling();
            startStatsPolling();
            console.log('âœ… Main polling started');
            
            // Check bulk import status on load
            fetch('/dropbox/bulk_import/status')
                .then(r => r.json())
                .then(data => {
                    console.log('ðŸ“¦ Bulk import status:', data);
                    if (data.active || (data.status && data.status !== 'idle' && data.status !== 'stopped')) {
                        console.log('ðŸ”„ Active bulk import detected, resuming display...');
                        // Show sidebar card
                        document.getElementById('dropboxImportCard').style.display = 'block';
                        document.getElementById('dropboxQuickCard').style.display = 'none';
                        showBulkImportPanel();
                        startBulkImportPolling();
                        showToast('ðŸ“¦ Bulk import in progress - resuming display');
                    } else {
                        // Show quick import button
                        document.getElementById('dropboxImportCard').style.display = 'none';
                        document.getElementById('dropboxQuickCard').style.display = 'block';
                    }
                    lucide.createIcons();
                })
                .catch(e => console.error('Error checking bulk import:', e));
            
            // Also check main status for queue items
            fetch('/status')
                .then(r => r.json())
                .then(data => {
                    console.log('ðŸ“Š Status check - queue_items:', data.queue_items?.length || 0);
                    if (data.queue_items && data.queue_items.length > 0) {
                        syncTracksFromQueueItems(data.queue_items, [], data.failed_files || []);
                        updateCurrentProcessingCard(data.queue_items);
                    }
                })
                .catch(e => console.error('Error checking status:', e));
        });
        
        function toggleDropboxFile(index) {
            if (selectedDropboxFiles.has(index)) {
                selectedDropboxFiles.delete(index);
            } else {
                selectedDropboxFiles.add(index);
            }
            
            // Update UI
            const items = document.querySelectorAll('.dropbox-file-item');
            items.forEach((item, i) => {
                if (selectedDropboxFiles.has(i)) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
            
            updateDropboxImportButton();
        }
        
        function selectAllDropboxFiles() {
            dropboxFiles.forEach((_, index) => selectedDropboxFiles.add(index));
            document.querySelectorAll('.dropbox-file-item').forEach(item => item.classList.add('selected'));
            updateDropboxImportButton();
        }
        
        function deselectAllDropboxFiles() {
            selectedDropboxFiles.clear();
            document.querySelectorAll('.dropbox-file-item').forEach(item => item.classList.remove('selected'));
            updateDropboxImportButton();
        }
        
        function updateDropboxImportButton() {
            const importBtn = document.getElementById('dropboxImportBtn');
            const count = selectedDropboxFiles.size;
            importBtn.disabled = count === 0;
            importBtn.innerHTML = `<i data-lucide="download"></i> Import ${count} File${count !== 1 ? 's' : ''}`;
            lucide.createIcons();
        }
        
        async function startDropboxImport() {
            if (selectedDropboxFiles.size === 0) {
                showToast('Please select files to import');
                return;
            }
            
            const folderPath = document.getElementById('dropboxFolderPath').value.trim();
            const selectedPaths = Array.from(selectedDropboxFiles).map(index => dropboxFiles[index].path);
            
            const importBtn = document.getElementById('dropboxImportBtn');
            importBtn.disabled = true;
            importBtn.innerHTML = '<i data-lucide="loader-2" class="spin"></i> Starting...';
            lucide.createIcons();
            
            // Show progress section
            document.getElementById('dropboxImportProgress').style.display = 'block';
            document.getElementById('dropboxProgressFill').style.width = '0%';
            document.getElementById('dropboxProgressValue').textContent = '0%';
            document.getElementById('dropboxStatusText').textContent = 'Starting download from Dropbox...';
            
            try {
                const response = await fetch('/dropbox/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder_path: folderPath,
                        files: selectedPaths
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    showToast(data.error || 'Error starting import', 'error');
                    document.getElementById('dropboxImportProgress').style.display = 'none';
                    importBtn.disabled = false;
                    importBtn.innerHTML = `<i data-lucide="download"></i> Import ${selectedDropboxFiles.size} Files`;
                    lucide.createIcons();
                    return;
                }
                
                currentDropboxImportId = data.import_id;
                showToast(`Started importing ${data.total_files} files from Dropbox`);
                
                // Start polling for progress
                startDropboxProgressPolling();
                
            } catch (error) {
                console.error('Error starting Dropbox import:', error);
                showToast('Error starting import', 'error');
                document.getElementById('dropboxImportProgress').style.display = 'none';
                importBtn.disabled = false;
                importBtn.innerHTML = `<i data-lucide="download"></i> Import ${selectedDropboxFiles.size} Files`;
                lucide.createIcons();
            }
        }
        
        function startDropboxProgressPolling() {
            if (dropboxPollingInterval) {
                clearInterval(dropboxPollingInterval);
            }
            
            dropboxPollingInterval = setInterval(async () => {
                if (!currentDropboxImportId) return;
                
                try {
                    const response = await fetch(`/dropbox/status/${currentDropboxImportId}`);
                    const status = await response.json();
                    
                    if (response.status === 404) {
                        clearInterval(dropboxPollingInterval);
                        dropboxPollingInterval = null;
                        return;
                    }
                    
                    // Update progress UI
                    const total = status.total || 1;
                    const downloaded = status.downloaded || 0;
                    const queued = status.queued || 0;
                    const failed = status.failed || 0;
                    
                    let progress = 0;
                    let statusText = '';
                    
                    if (status.status === 'downloading') {
                        progress = Math.round((downloaded / total) * 50);
                        statusText = `Downloading: ${downloaded}/${total} files...`;
                    } else if (status.status === 'queueing') {
                        progress = 50 + Math.round((queued / total) * 25);
                        statusText = `Queueing for processing: ${queued}/${total} files...`;
                    } else if (status.status === 'processing') {
                        progress = 75;
                        statusText = `Processing: ${queued} files queued for analysis`;
                    }
                    
                    document.getElementById('dropboxProgressFill').style.width = progress + '%';
                    document.getElementById('dropboxProgressValue').textContent = progress + '%';
                    document.getElementById('dropboxStatusText').textContent = statusText;
                    
                    // Check if complete
                    if (status.status === 'processing') {
                        // Import phase complete, files are now in processing queue
                        document.getElementById('dropboxProgressFill').style.width = '100%';
                        document.getElementById('dropboxProgressValue').textContent = '100%';
                        document.getElementById('dropboxStatusText').textContent = 
                            `Import complete! ${downloaded} files downloaded, ${queued} queued for processing` + 
                            (failed > 0 ? `, ${failed} failed` : '');
                        
                        clearInterval(dropboxPollingInterval);
                        dropboxPollingInterval = null;
                        
                        // Update import button
                        const importBtn = document.getElementById('dropboxImportBtn');
                        importBtn.innerHTML = '<i data-lucide="check"></i> Import Complete';
                        importBtn.disabled = true;
                        lucide.createIcons();
                        
                        // Start main polling to track processing
                        if (!pollingInterval) startPolling();
                        if (!statsInterval) startStatsPolling();
                        
                        showToast(`${queued} files from Dropbox queued for processing`);
                        
                        // Auto-close modal after delay
                        setTimeout(() => {
                            closeDropboxModal();
                        }, 2000);
                    }
                    
                } catch (error) {
                    console.error('Error polling Dropbox status:', error);
                }
            }, 1000);
        }
    </script>
</body>
</html>
